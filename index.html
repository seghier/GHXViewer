<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Grasshopper GHX Editor with SVG Viewer</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script>
    <style>
        /* Update the color palette and styling to match the image */
        :root {
            --bg-color: #e6e9ef;
            --shadow-dark: rgba(163, 177, 198, 0.6);
            --shadow-light: rgba(255, 255, 255, 0.9);
            --text-color: #5b7a9d;
            --icon-color: #4a69bd;
        }

        body {
            font-family:
                "Inter",
                "SF Pro Display",
                -apple-system,
                BlinkMacSystemFont,
                "Segoe UI",
                Roboto,
                "Helvetica Neue",
                Arial,
                sans-serif;
            display: flex;
            margin: 0;
            padding: 0;
            height: 100vh;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        #side-panel-wrapper {
            user-select: none;
            width: 400px;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #ddd;
            background-color: var(--bg-color);
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
        }

        /* Button container - making it transparent/flat */
        .button-container {
            padding: 20px;
            background: transparent;
            display: flex;
            gap: 1px;
            justify-content: space-between;
            box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.1);
        }

        #side-panel {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            padding-right: 10px;
        }

        /* Section styles */
        .sectionPanel {
            margin-bottom: 15px;
            padding: 15px;
            border-radius: 15px;
            background: var(--bg-color);
            box-shadow:
                6px 6px 10px var(--shadow-dark),
                -4px -4px 8px var(--shadow-light);
            border: none;
        }

        /* Section header with gradient and proper neumorphic effect */
        .sectionHeader {
            cursor: pointer;
            background: linear-gradient(145deg, #00a2ff, #0078d7);
            padding: 12px 15px;
            margin: -15px -15px 15px -15px;
            font-size: 15px;
            color: white;
            border-radius: 15px 15px 0 0;
            font-weight: 500;
            letter-spacing: 0.3px;
            box-shadow:
                2px 2px 4px rgba(0, 0, 0, 0.2),
                -1px -1px 3px rgba(255, 255, 255, 0.1);
        }

        .sectionHeader:hover {
            background: linear-gradient(145deg, #2d5aed, #4a69bd);
        }

        .sectionHeader.active {
            box-shadow:
                inset 2px 2px 5px rgba(0, 0, 0, 0.2),
                inset -2px -2px 5px rgba(255, 255, 255, 0.1);
        }

        .sectionContent {
            padding: 4px;
            display: none;
        }

        /* Component panel styles */
        .componentPanel {
            border: none;
            padding: 15px;
            margin: 10px 0;
            border-radius: 12px;
            background: #f0f4f8;
            /* Lighter background for subsections */
            box-shadow:
                3px 3px 6px var(--shadow-dark),
                -3px -3px 6px var(--shadow-light);
        }

        .collapsibleHeader {
            cursor: pointer;
            background: var(--bg-color);
            padding: 12px 20px;
            margin: -15px -15px 15px -15px;
            font-size: 14px;
            color: var(--text-color);
            border-radius: 12px 12px 0 0;
            font-weight: 500;
            box-shadow:
                4px 4px 8px var(--shadow-dark),
                -4px -4px 8px var(--shadow-light);
            transition: all 0.3s ease;
        }

        .collapsibleHeader.active {
            box-shadow:
                inset 2px 2px 5px var(--shadow-dark),
                inset -2px -2px 5px var(--shadow-light);
        }

        /* Form elements */
        .componentPanel label {
            display: block;
            margin: 8px 0 4px 0;
            font-weight: 500;
            font-size: 13px;
            color: var(--text-color);
        }

        /* Input fields with smoke white background */
        .componentPanel input[type="text"],
        .componentPanel input[type="number"],
        .componentPanel textarea {
            width: 100%;
            padding: 8px 12px;
            margin-top: 2px;
            box-sizing: border-box;
            font-size: 13px;
            border: none;
            border-radius: 8px;
            background: #f8fafc;
            /* Smoke white color */
            color: var(--text-color);
            box-shadow:
                inset 2px 2px 4px rgba(163, 177, 198, 0.4),
                inset -2px -2px 4px rgba(255, 255, 255, 0.8);
        }

        /* Make textarea only vertically resizable */
        .componentPanel textarea {
            resize: vertical;
            min-height: 60px;
        }

        /* Add hover effect for inputs */
        .componentPanel input[type="text"]:hover,
        .componentPanel input[type="number"]:hover,
        .componentPanel textarea:hover {
            background: #ffffff;
        }

        /* Add focus effect for inputs */
        .componentPanel input[type="text"]:focus,
        .componentPanel input[type="number"]:focus,
        .componentPanel textarea:focus {
            background: #ffffff;
            outline: none;
            box-shadow:
                inset 2px 2px 4px rgba(163, 177, 198, 0.6),
                inset -2px -2px 4px rgba(255, 255, 255, 0.9);
        }

        /* Updated button style with stronger neumorphic effect */
        button {
            padding: 15px 30px;
            border: none;
            border-radius: 50px;
            background: var(--bg-color);
            box-shadow:
                6px 6px 12px var(--shadow-dark),
                -6px -6px 12px var(--shadow-light);
            color: var(--text-color);
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
            margin: 0;
        }

        button:hover {
            color: var(--icon-color);
            box-shadow:
                2px 2px 4px var(--shadow-dark),
                -2px -2px 4px var(--shadow-light);
        }

        button:active {
            box-shadow:
                inset 4px 4px 8px var(--shadow-dark),
                inset -4px -4px 8px var(--shadow-light);
            transform: translateY(1px);
        }

        /* SVG viewer styles */
        #svgViewer {
            width: 100%;
            height: 97%;
            /*border: 1px solid #e2e8f0;*/
            border-radius: 16px;
            padding-top: 2px;
            min-height: 80vh;
            position: relative;
            background-color: #efefef;
            background-image: linear-gradient(0deg, rgba(180, 189, 200, 0.4) 1px, transparent 1px),
                linear-gradient(90deg, rgba(203, 213, 225, 0.4) 1px, transparent 1px);
            background-size: 100px 50px;
            box-shadow: inset 0 0 7px rgba(0, 0, 0, 0.25);
            overflow: hidden;
        }

        /* XML content styles */
        #xmlContainer {
            margin-top: 10px;
            border-radius: 8px;
            background-color: #f5f5f5;
        }

        .xml-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: #f8f9fa;
            border-bottom: 1px solid #ddd;
            border-radius: 8px 8px 0 0;
        }

        #fileContent {
            height: 800px;
            overflow-y: auto;
            display: none;
            background-color: #f5f5f5;
            padding: 20px;
            border-radius: 0 0 8px 8px;
            font-family: "Consolas", "Monaco", "Andale Mono", monospace;
            font-size: 14px;
            line-height: 1.4;
            white-space: pre;
            word-wrap: normal;
            overflow-x: auto;
            margin: 0;
        }

        /* Toggle button style matching the image */
        .toggle-button {
            position: relative;
            width: 120px;
            height: 40px;
            background: var(--bg-color);
            border-radius: 20px;
            box-shadow:
                inset 3px 3px 7px var(--shadow-dark),
                inset -3px -3px 7px var(--shadow-light);
            cursor: pointer;
            display: flex;
            align-items: center;
            padding: 0 5px;
            margin: 15px;
        }

        .toggle-slider {
            position: absolute;
            width: 50px;
            height: 30px;
            background: var(--bg-color);
            border-radius: 15px;
            box-shadow:
                4px 4px 8px var(--shadow-dark),
                -4px -4px 8px var(--shadow-light);
            transition: transform 0.3s ease;
            left: 5px;
        }

        .toggle-button.xml .toggle-slider {
            transform: translateX(60px);
        }

        .toggle-text {
            position: absolute;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-color);
            transition: opacity 0.3s ease;
        }

        .toggle-text.ghx {
            left: 15px;
        }

        .toggle-text.xml {
            right: 15px;
        }

        .toggle-button.xml .toggle-text.ghx,
        .toggle-button:not(.xml) .toggle-text.xml {
            opacity: 0.4;
        }

        /* Main area styles */
        #main {
            flex: 1;
            padding: 17px;
            overflow-y: auto;
            position: relative;
            background-color: var(--bg-color);
        }

        /* SVG specific styles */
        svg {
            width: 100%;
            height: 100%;
            border: 1px solid #ddd;
            margin-top: 10px;
            background-color: #2d2d2d;
            border-radius: 8px;
            position: absolute;
            top: 0;
            left: 0;
            cursor: default;
            user-select: none;
        }

        .draggable {
            user-select: none;
        }

        /* Color input styles */
        .colorInputGroup {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 5px;
        }

        .colorPicker {
            width: 50px;
            height: 30px;
            padding: 0;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        /* Component highlight effects */
        .component {
            transition:
                stroke 0.2s ease,
                stroke-width 0.2s ease,
                filter 0.2s ease;
        }

        .highlight {
            stroke: #2196f3 !important;
            stroke-width: 1px !important;
            filter: drop-shadow(0 0 5px rgba(33, 150, 243, 0.7));
            animation: pulse 0.8s infinite alternate;
        }

        @keyframes pulse {
            from {
                stroke-width: 1px;
                filter: drop-shadow(0 0 3px rgba(33, 150, 243, 0.5));
            }

            to {
                stroke-width: 2px;
                filter: drop-shadow(0 0 8px rgba(33, 150, 243, 0.9));
            }
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.5);
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .modal.show {
            display: block;
            opacity: 1;
        }

        .modal-content {
            background-color: #ffffff;
            margin: 20% auto;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            width: 300px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        /* Filename display */
        #filenameDisplay {
            display: none;
            user-select: none;
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 18px;
            color: #333;
            z-index: 100;
        }

        /* Global scrollbar styling for entire app */
        * {
            scrollbar-width: thin;
            /* For Firefox */
            scrollbar-color: #c1c2c5 #f1f1f1;
            /* For Firefox */
        }

        /* Webkit scrollbar styling for all elements */
        *::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        *::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 8px;
            margin: 3px;
        }

        *::-webkit-scrollbar-thumb {
            background-color: #c1c2c5;
            border-radius: 6px;
            border: 3px solid #f1f1f1;
        }

        *::-webkit-scrollbar-thumb:hover {
            background-color: #979da1;
        }

        *::-webkit-scrollbar-corner {
            background: #f1f1f1;
        }

        /* Update the popup message styles to match the neumorphic theme */
        .popup-message {
            display: none;
            position: fixed;
            top: 50%;
            /* Center vertically */
            left: 50%;
            transform: translate(-50%, -50%);
            /* Center both vertically and horizontally */
            background: var(--bg-color);
            color: var(--text-color);
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 14px;
            font-weight: 600;
            text-align: center;
            white-space: nowrap;
            z-index: 1000;
            opacity: 0;
            box-shadow:
                6px 6px 12px var(--shadow-dark),
                -6px -6px 12px var(--shadow-light);
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .popup-message.show {
            opacity: 1;
        }

        /* Update error state */
        .popup-message.error {
            color: #dc3545;
            box-shadow:
                6px 6px 12px rgba(220, 53, 69, 0.3),
                -6px -6px 12px var(--shadow-light);
        }

        /* Updated toggle switch to match image exactly */
        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 8px 0;
        }

        .toggle-switch input[type="checkbox"] {
            display: none;
        }

        .toggle-switch label {
            position: relative;
            display: inline-flex;
            align-items: center;
            cursor: pointer;
            margin: 0;
            padding: 0;
            font-size: 14px;
            color: var(--text-color);
        }

        .toggle-switch label:before {
            content: "";
            width: 24px;
            height: 24px;
            margin-right: 10px;
            border-radius: 8px;
            background: var(--bg-color);
            box-shadow:
                2px 2px 4px var(--shadow-dark),
                -2px -2px 4px var(--shadow-light);
            transition: all 0.3s ease;
        }

        .toggle-switch input:checked+label:before {
            background: linear-gradient(145deg, #00a2ff, #0078d7);
            box-shadow:
                inset 2px 2px 4px rgba(0, 0, 0, 0.2),
                inset -1px -1px 3px rgba(255, 255, 255, 0.1);
        }

        .toggle-switch input:checked+label:after {
            content: "✓";
            position: absolute;
            left: 7px;
            color: white;
            font-size: 14px;
            font-weight: bold;
        }

        /* Custom checkbox styling to match the image */
        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
        }

        .checkbox-wrapper input[type="checkbox"] {
            display: none;
        }

        .checkbox-wrapper label {
            position: relative;
            display: inline-flex;
            align-items: center;
            cursor: pointer;
            margin: 0;
            padding: 0;
            font-size: 14px;
            color: var(--text-color);
        }

        .checkbox-wrapper label:before {
            content: "";
            width: 24px;
            height: 24px;
            margin-right: 10px;
            border-radius: 8px;
            background: var(--bg-color);
            box-shadow:
                2px 2px 4px var(--shadow-dark),
                -2px -2px 4px var(--shadow-light);
            transition: all 0.3s ease;
        }

        .checkbox-wrapper input[type="checkbox"]:checked+label:before {
            background: linear-gradient(145deg, #00a2ff, #0078d7);
            box-shadow:
                inset 2px 2px 4px rgba(0, 0, 0, 0.2),
                inset -1px -1px 3px rgba(255, 255, 255, 0.1);
        }

        .checkbox-wrapper input[type="checkbox"]:checked+label:after {
            content: "✓";
            position: absolute;
            left: 7px;
            color: white;
            font-size: 14px;
            font-weight: bold;
        }

        /* Section and subsection highlight styles */
        .sectionPanel.selected {
            box-shadow:
                0 0 15px rgba(0, 162, 255, 0.3),
                4px 4px 8px var(--shadow-dark),
                -4px -4px 8px var(--shadow-light);
            transition: box-shadow 0.3s ease;
        }

        .componentPanel.selected {
            box-shadow:
                0 0 12px rgba(72, 187, 120, 0.3),
                3px 3px 6px var(--shadow-dark),
                -3px -3px 6px var(--shadow-light);
            background: #e8f5e9;
            transition: all 0.3s ease;
        }

        /* Component highlight on double click */
        .highlight-orange {
            stroke: #ff9800 !important;
            stroke-width: 1px !important;
            filter: drop-shadow(0 0 8px rgba(255, 152, 0, 0.6));
            animation: pulseOrange 2s ease-out forwards;
        }

        @keyframes pulseOrange {
            0% {
                stroke-width: 2px;
                filter: drop-shadow(0 0 8px rgba(255, 152, 0, 0.8));
            }

            100% {
                stroke-width: 1px;
                filter: none;
            }
        }

        /* Add this to the modal styles section */
        .modal-buttons {
            display: flex;
            gap: 30px;
            justify-content: center;
            margin-top: 25px;
        }

        /* Update existing button styles in modals */
        .modal-content button {
            min-width: 100px;
            padding: 12px 25px;
            margin: 0;
        }

        /* If you have specific confirmation dialogs, add this */
        .confirm-dialog-buttons {
            display: flex;
            gap: 25px;
            justify-content: center;
            margin-top: 20px;
        }
    </style>
</head>

<body>
    <!-- Side panel with attribute editors -->
    <div id="side-panel-wrapper">
        <div class="button-container">
            <button id="openBtn">Open</button>
            <input type="file" id="fileInput" accept=".ghx, .xml" style="display: none" />
            <button id="saveBtn">Save</button>
            <button id="saveSvgBtn">Save SVG</button>
        </div>
        <!-- Scrollable panel content -->
        <div id="side-panel">
            <div class="sectionPanel">
                <h2 class="sectionHeader">Sliders</h2>
                <div class="sectionContent" id="slidersContainer"></div>
            </div>
            <div class="sectionPanel">
                <h2 class="sectionHeader">Genne Pools</h2>
                <div class="sectionContent" id="genePoolContainer"></div>
            </div>
            <div class="sectionPanel">
                <h2 class="sectionHeader">Boolean Toggles</h2>
                <div class="sectionContent" id="togglesContainer"></div>
            </div>
            <div class="sectionPanel">
                <h2 class="sectionHeader">Panels</h2>
                <div class="sectionContent" id="panelsContainer"></div>
            </div>
            <div class="sectionPanel">
                <h2 class="sectionHeader">Expressions</h2>
                <div class="sectionContent" id="expressionsContainer"></div>
            </div>
            <div class="sectionPanel">
                <h2 class="sectionHeader">Value Lists</h2>
                <div class="sectionContent" id="valueListsContainer"></div>
            </div>
            <div class="sectionPanel">
                <h2 class="sectionHeader">Scribbles</h2>
                <div class="sectionContent" id="scribblesContainer"></div>
            </div>
            <div class="sectionPanel">
                <h2 class="sectionHeader">GHPython Components</h2>
                <div class="sectionContent" id="pythonContainer"></div>
            </div>
            <div class="sectionPanel">
                <h2 class="sectionHeader">C# Components</h2>
                <div class="sectionContent" id="csharpContainer"></div>
            </div>
            <div class="sectionPanel" style="display: none">
                <h2 class="sectionHeader">Sketches</h2>
                <div class="sectionContent" id="sketchesContainer"></div>
            </div>
            <div class="sectionPanel">
                <h2 class="sectionHeader">Color Swatches</h2>
                <div class="sectionContent" id="colorSwatchContainer"></div>
            </div>

            <div class="sectionPanel">
                <h2 class="sectionHeader">Persistent Data</h2>
                <div class="sectionContent" id="persistentDataContainer"></div>
            </div>

            <div class="sectionPanel">
                <h2 class="sectionHeader">Other Components</h2>
                <div class="sectionContent" id="generalContainer"></div>
            </div>

            <div class="sectionPanel">
                <h2 class="sectionHeader">Placeholders</h2>
                <div class="sectionContent" id="placeholderContainer"></div>
            </div>
        </div>
    </div>

    <!-- Main area with SVG viewer and XML content -->
    <div id="main">
        <div id="filenameDisplay"></div>
        <svg id="svgViewer"></svg>

        <!-- XML content container -->
        <div id="xmlContainer">
            <div id="xmlControls" style="display: none">
                <div class="xml-toolbar">
                    <div class="toolbar-left">
                        <button id="copyXmlBtn" class="xml-btn">
                            <span class="btn-text">Copy</span>
                        </button>
                        <button id="toggleFormatBtn" class="xml-btn">
                            <span class="btn-text">Toggle GHX/XML</span>
                        </button>
                    </div>
                </div>
            </div>
            <pre id="fileContent" class="language-markup"></pre>
        </div>
    </div>
    <!-- Save Confirmation Modal -->
    <div id="savePopup" class="modal">
        <div class="modal-content">
            <p>Do you want to save the current file?</p>
            <div class="modal-buttons">
                <button id="saveYesBtn">Yes</button>
                <button id="saveNoBtn">No</button>
            </div>
        </div>
    </div>

    <!-- Single popup message element -->
    <div id="popupMessage" class="popup-message" style="display: none"></div>

    <script>
        // Global variables

        let panZoomGroup = null;
        let zoomHandler = null;

        let isDragging = false;
        let currentComponent = null;
        let currentRectangle = null;
        let offset = { x: 0, y: 0 };
        let svgElement = null;
        let componentsData = [];
        let connectionsData = [];
        let dragStartTime = 0;
        const CLICK_THRESHOLD = 200; // ms threshold
        // Add this variable at the top with other global variables
        let finalSvg = "";

        // Global pan/zoom variables.
        let panOffset = { tx: 0, ty: 0 };
        let zoomSpeed = 0.001;
        let minZoom = 0.1;
        let maxZoom = 10;

        let xmlDoc = null;
        let fileName = "modified.ghx";
        let originalXmlText = "";

        // Arrays for our components
        let pythonObjects = [];
        let csharpObjects = [];

        // Arrays for different component types
        let sliderObjects = [];
        let toggleObjects = [];
        let panelObjects = [];
        let expressionObjects = [];
        let valueListObjects = [];
        let genePoolObjects = [];

        const sectionGuids = {
            sliders: new Set(),
            toggles: new Set(),
            panels: new Set(),
            expressions: new Set(),
            valueLists: new Set(),
            persistentData: new Set(),
            python: new Set(),
            csharp: new Set(),
            general: new Set(),
            colorSwatches: new Set(),
            scribbles: new Set(),
            sketches: new Set(),
            genePools: new Set(),
            placeHolders: new Set()
        };

        // DOM element references
        const fileInput = document.getElementById("fileInput");
        const openBtn = document.getElementById("openBtn");
        const saveBtn = document.getElementById("saveBtn");
        const fileContent = document.getElementById("fileContent");
        const slidersContainer = document.getElementById("slidersContainer");
        const togglesContainer = document.getElementById("togglesContainer");
        const panelsContainer = document.getElementById("panelsContainer");
        const expressionsContainer = document.getElementById("expressionsContainer");
        const valueListsContainer = document.getElementById("valueListsContainer");
        const persistentDataContainer = document.getElementById("persistentDataContainer");
        const pythonContainer = document.getElementById("pythonContainer");
        const csharpContainer = document.getElementById("csharpContainer");
        const scribblesContainer = document.getElementById("scribblesContainer");
        const sketchesContainer = document.getElementById("sketchesContainer");
        const generalContainer = document.getElementById("generalContainer");
        const colorSwatchContainer = document.getElementById("colorSwatchContainer");
        const genePoolContainer = document.getElementById("genePoolContainer");
        const placeholderContainer = document.getElementById("placeholderContainer");

        let currentFormat = "original"; // Can be 'original' or 'converted'
        let originalContent = "";

        // Add these global variables near the top with other globals
        let showComponentNames = true; // Toggle for component names visibility
        const ICON_SIZE = 24; // Icon size in pixels

        // Add this function after your other utility functions
        function getIconPath(name) {
            // Use instanceGuid for the icon name
            return `icons/${name}.png`;
        }

        // Add this at the end of your script
        ////document.addEventListener('DOMContentLoaded', (event) => {
        //Prism.highlightAll();
        //});
        // Toggle format button functionality

        document.getElementById("toggleFormatBtn").addEventListener("click", function () {
            const fileContent = document.getElementById("fileContent");
            const codeElement = fileContent.querySelector("code");

            if (currentFormat === "original") {
                // Convert to the other format
                const convertedXml = convertFormat(originalContent);
                displayFormattedXML(convertedXml);
                currentFormat = "converted";
                this.querySelector(".btn-text").textContent = "Show Original";
            } else {
                // Show original
                displayFormattedXML(originalContent);
                currentFormat = "original";
                this.querySelector(".btn-text").textContent = "Toggle GHX/XML";
            }
        });

        function convertFormat(xmlContent) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlContent, "text/xml");

            // Determine current format by checking for Definition or Clipboard chunk
            const isGhx = xmlDoc.querySelector('chunk[name="Definition"]') !== null;

            if (isGhx) {
                // Converting from GHX to XML
                // Remove Thumbnail chunk if it exists
                const thumbnailChunk = xmlDoc.querySelector('chunk[name="Thumbnail"]');
                if (thumbnailChunk) {
                    thumbnailChunk.parentNode.removeChild(thumbnailChunk);
                }

                // Change Definition to Clipboard
                const definitionChunk = xmlDoc.querySelector('chunk[name="Definition"]');
                if (definitionChunk) {
                    definitionChunk.setAttribute("name", "Clipboard");
                }
            } else {
                // Converting from XML to GHX
                // Change Clipboard to Definition
                const clipboardChunk = xmlDoc.querySelector('chunk[name="Clipboard"]');
                if (clipboardChunk) {
                    clipboardChunk.setAttribute("name", "Definition");
                }

                // We don't add Thumbnail chunk when converting to GHX
                // as it's not necessary for functionality
            }

            // Convert back to string
            const serializer = new XMLSerializer();
            return serializer.serializeToString(xmlDoc);
        }

        // Copy button functionality
        document.getElementById("copyXmlBtn").addEventListener("click", function () {
            const xmlContent = document.getElementById("fileContent").textContent;
            navigator.clipboard.writeText(xmlContent).then(() => {
                const btnText = this.querySelector(".btn-text");
                const originalText = btnText.textContent;
                btnText.textContent = "Copied!";
                setTimeout(() => {
                    btnText.textContent = originalText;
                }, 2000);
            });
        });

        // Update the show/hide handler to store original content
        document.addEventListener("keydown", function (event) {
            const fileContent = document.getElementById("fileContent");
            const xmlControls = document.getElementById("xmlControls");

            if (event.key === " ") {
                // Spacebar
                event.preventDefault(); // Prevent page scrolling
                // Toggle visibility based on current state
                if (fileContent.style.display === "none" || fileContent.style.display === "") {
                    // If hidden, show and format
                    originalContent = fileContent.textContent;
                    currentFormat = "original";
                    document.querySelector("#toggleFormatBtn .btn-text").textContent = "Toggle GHX/XML";
                    displayFormattedXML(originalContent);
                    fileContent.style.display = "block";
                    xmlControls.style.display = "block";
                } else {
                    // If visible, hide
                    fileContent.style.display = "none";
                    xmlControls.style.display = "none";
                }
            }
        });

        function updateFileContent(xmlContent) {
            const fileContent = document.getElementById("fileContent");
            originalContent = xmlContent; // Store the new content
            currentFormat = "original"; // Reset format state

            // Reset toggle button text
            document.querySelector("#toggleFormatBtn .btn-text").textContent = "Toggle GHX/XML";

            // Format and display the XML
            displayFormattedXML(xmlContent);
        }

        function displayFormattedXML(xmlString) {
            const fileContent = document.getElementById("fileContent");

            // Format the XML
            const formattedXML = formatXML(xmlString);

            // Escape HTML entities to prevent XSS and preserve spaces
            const escapedXML = formattedXML
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;")
                .replace(/ /g, "&nbsp;");

            // Apply Prism highlighting and show the content
            fileContent.innerHTML = `<code class="language-markup">${escapedXML}</code>`;
            Prism.highlightElement(fileContent.querySelector("code"));
        }

        // Helper function to format XML
        function formatXML(xml) {
            const PADDING = " ".repeat(2); // 2 spaces for indentation
            const reg = /(>)(<)(\/*)/g;
            let pad = 0;

            return xml
                .replace(reg, "$1\n$2$3")
                .split("\n")
                .map((node, index) => {
                    let indent = 0;
                    if (node.match(/.+<\/\w[^>]*>$/)) {
                        indent = 0;
                    } else if (node.match(/^<\/\w/)) {
                        if (pad !== 0) {
                            pad -= 1;
                        }
                    } else if (node.match(/^<\w[^>]*[^\/]>.*$/)) {
                        indent = 1;
                    } else {
                        indent = 0;
                    }
                    pad += indent;
                    return PADDING.repeat(pad - indent) + node;
                })
                .join("\n");
        }

        // Helper function to attach collapse/expand behavior to section headers
        function attachSectionCollapse() {
            document.querySelectorAll(".sectionHeader").forEach((header) => {
                header.addEventListener("click", function () {
                    console.log("Section header clicked"); // Debug log
                    const content = header.nextElementSibling;
                    if (content) {
                        // Use getComputedStyle to get the actual display value.
                        const currentDisplay = window.getComputedStyle(content).display;
                        content.style.display = currentDisplay === "none" ? "block" : "none";
                    }
                });
            });
        }

        function updateSectionCounts() {
            document.querySelectorAll(".sectionPanel").forEach((panel) => {
                const header = panel.querySelector(".sectionHeader");
                const content = panel.querySelector(".sectionContent");
                if (header && content) {
                    const count = content.childElementCount;
                    // Remove any previous count in parentheses.
                    header.textContent = header.textContent.replace(/\s*\(\d+\)/, "");
                    header.textContent += " (" + count + ")";
                }
            });
        }

        // Helper function to attach collapse/expand behavior to individual component panels
        function attachCollapseFor(container) {
            container.querySelectorAll(".collapsibleHeader").forEach((header) => {
                header.addEventListener("click", function () {
                    const content = header.nextElementSibling;
                    content.style.display = content.style.display === "none" ? "block" : "none";
                });
            });
        }
        // --- Utility Function ---
        function parseValue(val) {
            if (!val || val.trim() === "") return null;
            const trimmed = val.trim();
            const lower = trimmed.toLowerCase();
            if (lower === "true") return true;
            if (lower === "false") return false;
            const num = Number(trimmed);
            if (!isNaN(num)) return num;
            return trimmed;
        }

        // --- Recursive extraction of persistent data (for SVG display, if needed) ---
        function extractPersistentData(el) {
            let results = [];
            const items = el.querySelectorAll(":scope > items > item");
            items.forEach((item) => {
                const key = item.getAttribute("name");
                if (key === "Count" || key === "Path" || key === "null_string") return;
                const rawVal = item.textContent.trim();
                const parsedVal = parseValue(rawVal);
                if (
                    parsedVal !== null &&
                    (typeof parsedVal === "string" ||
                        typeof parsedVal === "number" ||
                        typeof parsedVal === "boolean")
                ) {
                    results.push(`${key}: ${parsedVal}`);
                }
            });
            const chunks = el.querySelectorAll(":scope > chunks > chunk");
            chunks.forEach((chunk) => {
                results = results.concat(extractPersistentData(chunk));
            });
            return results;
        }

        function collapseAllSectionsExcept(targetSection) {
            document.querySelectorAll(".sectionPanel").forEach((panel) => {
                const content = panel.querySelector(".sectionContent");
                if (panel !== targetSection) {
                    if (content) {
                        content.style.display = "none";
                    }
                } else {
                    if (content) {
                        content.style.display = "block";
                    }
                }
            });
        }

        function updateSwatchColor(containerChunk, alpha, red, green, blue) {
            const colorItem = containerChunk.querySelector('item[name="SwatchColor"] ARGB');
            if (colorItem) {
                colorItem.textContent = `${alpha};${red};${green};${blue}`;
            }
        }
        function updateSketchColor(containerChunk, hexColor) {
            // Find the SketchProperties chunk
            const sketchProps = containerChunk.querySelector(
                'chunk[name="Attributes"] chunk[name="SketchProperties"]'
            );
            // Locate the Color item
            const colorItem = sketchProps?.querySelector('item[name="Color"]');
            if (colorItem) {
                // Try to find the ARGB element inside the Color item
                let argbElem = colorItem.querySelector("ARGB");
                if (!argbElem) {
                    // If ARGB doesn't exist, create it and append it to the colorItem
                    argbElem = document.createElement("ARGB");
                    colorItem.appendChild(argbElem);
                }
                // Convert the hex color to RGB components
                const r = parseInt(hexColor.slice(1, 3), 16);
                const g = parseInt(hexColor.slice(3, 5), 16);
                const b = parseInt(hexColor.slice(5, 7), 16);
                // Update the ARGB text content (assuming alpha = 255)
                argbElem.textContent = `255;${r};${g};${b}`;
            }
        }

        function argbToHex(argbString) {
            const [a, r, g, b] = argbString.split(";").map((num) => parseInt(num.trim(), 10));
            // Ignore alpha for the color input (or handle it as needed)
            return "#" + [r, g, b].map((x) => x.toString(16).padStart(2, "0")).join("");
        }

        // ----- PLACEHOLDERS -----
        function populatePlaceholderList() {
            // Clear existing GUIDs and container content
            sectionGuids.placeHolders.clear();
            placeholderContainer.innerHTML = "";

            // Find placeholder objects (those with a Lib attribute), but exclude Python scripts
            const placeholderObjects = Array.from(xmlDoc.querySelectorAll('chunk[name="Object"]')).filter((obj) => {
                const nameItem = obj.querySelector('item[name="Name"]');
                const libItem = obj.querySelector('item[name="Lib"]');
                return libItem !== null && nameItem?.textContent !== "GhPython Script";
            });

            placeholderObjects.forEach((placeholderObj, index) => {
                const containerChunk = placeholderObj.querySelector('chunk[name="Container"]');
                const instanceGuid = containerChunk?.querySelector('item[name="InstanceGuid"]')?.textContent;
                if (instanceGuid) {
                    sectionGuids.placeHolders.add(instanceGuid);
                }

                const nameVal = containerChunk?.querySelector('item[name="Name"]')?.textContent || "";
                const nicknameVal = containerChunk?.querySelector('item[name="NickName"]')?.textContent || "";
                const descriptionVal = containerChunk?.querySelector('item[name="Description"]')?.textContent || "";
                const libVal = placeholderObj.querySelector('item[name="Lib"]')?.textContent || "Unknown Plugin";

                const div = document.createElement("div");
                div.className = "componentPanel placeholder";
                div.dataset.guid = instanceGuid;
                div.innerHTML = `
            <h3 class="collapsibleHeader">Placeholder ${index + 1} (${nameVal})</h3>
            <div class="collapsibleContent">
                <label>Instance GUID</label>
                <input type="text" class="instanceGuid" value="${instanceGuid}" readonly>
                <label>Name</label>
                <input type="text" class="name" value="${nameVal}" readonly>
                <label>NickName</label>
                <input type="text" class="nickname" value="${nicknameVal}" readonly>
                <label>Description</label>
                <textarea class="description" rows="4" readonly>${descriptionVal}</textarea>
                <label>Plugin Library</label>
                <input type="text" class="library" value="${libVal}" readonly>
            </div>
        `;

                placeholderContainer.appendChild(div);
            });

            attachCollapseFor(placeholderContainer);
        }

        // ----- GENEPOOLS -----
        function populateGenePoolList() {
            // Clear existing GUIDs and container content (assume genePoolContainer is defined)
            sectionGuids.genePools.clear();
            genePoolContainer.innerHTML = "";

            // Find gene pool objects (those with a GeneData chunk)
            genePoolObjects = Array.from(xmlDoc.querySelectorAll('chunk[name="Object"]')).filter((obj) => {
                const container = obj.querySelector('chunk[name="Container"]');
                return container && container.querySelector('chunk[name="GeneData"]');
            });

            genePoolObjects.forEach((genePoolObj, index) => {
                const containerChunk = genePoolObj.querySelector('chunk[name="Container"]');
                const instanceGuid = containerChunk?.querySelector('item[name="InstanceGuid"]')?.textContent;
                if (instanceGuid) {
                    sectionGuids.genePools.add(instanceGuid);
                }
                const nameVal = containerChunk?.querySelector('item[name="Name"]')?.textContent || "";
                const nicknameVal = containerChunk?.querySelector('item[name="NickName"]')?.textContent || "";
                const lockedVal = containerChunk?.querySelector('item[name="Locked"]')?.textContent || "false";
                const descriptionVal = containerChunk?.querySelector('item[name="Description"]')?.textContent || "";

                // Get GeneData values
                const geneDataChunk = containerChunk.querySelector('chunk[name="GeneData"]');
                const countVal = geneDataChunk?.querySelector('item[name="Count"]')?.textContent || "0";
                const decimalsVal = geneDataChunk?.querySelector('item[name="Decimals"]')?.textContent || "";
                const maxVal = geneDataChunk?.querySelector('item[name="Maximum"]')?.textContent || "";
                const minVal = geneDataChunk?.querySelector('item[name="Minimum"]')?.textContent || "";

                // Get each gene value (items with name "Value")
                const geneValueItems = geneDataChunk.querySelectorAll('item[name="Value"]');
                let geneValues = [];
                geneValueItems.forEach((item) => {
                    geneValues.push(item.textContent);
                });

                // Build an HTML table for gene values
                const buildGeneValuesHtml = (count, currentValues) => {
                    let html = "";
                    // Use existing gene values if available; otherwise, use a default (0)
                    for (let i = 0; i < count; i++) {
                        const val = i < currentValues.length ? currentValues[i] : "0";
                        html += `<tr>
          <td>${i + 1}</td>
          <td><input type="number" class="geneValue" data-index="${i}" value="${val}" step="any"></td>
        </tr>`;
                    }
                    return html;
                };

                let geneValuesHtml = buildGeneValuesHtml(parseInt(countVal, 10), geneValues);

                // Build the panel's HTML with locked toggle added
                const div = document.createElement("div");
                div.className = "componentPanel genePoolPanel";
                div.dataset.guid = instanceGuid;
                div.innerHTML = `
      <h3 class="collapsibleHeader">Gene Pool ${index + 1} (${nameVal})</h3>
      <div class="collapsibleContent">
        <label>Name</label>
        <input type="text" class="name" value="${nameVal}">
        <label>NickName</label>
        <input type="text" class="nickname" value="${nicknameVal}">
        <label>Locked</label>
        <input type="checkbox" class="locked" ${lockedVal.toLowerCase() === "true" ? "checked" : ""}>
        <label>Description</label>
        <textarea class="description" rows="4">${descriptionVal}</textarea>
        <label>Count</label>
        <input type="number" class="count" value="${countVal}">
        <label>Decimals</label>
        <input type="number" class="decimals" value="${decimalsVal}">
        <label>Maximum</label>
        <input type="number" step="any" class="maximum" value="${maxVal}">
        <label>Minimum</label>
        <input type="number" step="any" class="minimum" value="${minVal}">
        <label>Gene Values</label>
        <table class="geneValuesTable">
          <thead>
            <tr>
              <th>#</th>
              <th>Value</th>
            </tr>
          </thead>
          <tbody>
            ${geneValuesHtml}
          </tbody>
        </table>
      </div>
    `;

                genePoolContainer.appendChild(div);

                // Attach event listener to update gene values rows when "Count" changes.
                const countInput = div.querySelector("input.count");
                const geneValuesTbody = div.querySelector(".geneValuesTable tbody");

                countInput.addEventListener("change", function () {
                    let newCount = parseInt(this.value, 10) || 0;
                    // Get the current gene values from the table (if any)
                    const currentValues = [];
                    geneValuesTbody.querySelectorAll("input.geneValue").forEach((input) => {
                        currentValues.push(input.value);
                    });
                    // Rebuild the table rows using the helper function
                    geneValuesTbody.innerHTML = buildGeneValuesHtml(newCount, currentValues);
                });
            });

            attachCollapseFor(genePoolContainer);
        }

        // ----- COLOR SWATCHES -----
        function populateColorSwatchList() {
            sectionGuids.colorSwatches.clear();
            colorSwatchContainer.innerHTML = "";

            const swatchObjects = Array.from(xmlDoc.querySelectorAll('chunk[name="Object"]')).filter((obj) => {
                const container = obj.querySelector('chunk[name="Container"]');
                return container && container.querySelector('item[name="SwatchColor"]');
            });

            swatchObjects.forEach((swatchObj, index) => {
                const containerChunk = swatchObj.querySelector('chunk[name="Container"]');
                const nameVal = containerChunk?.querySelector('item[name="Name"]')?.textContent || "";
                const nicknameVal = containerChunk?.querySelector('item[name="NickName"]')?.textContent || "";
                const lockedVal = containerChunk?.querySelector('item[name="Locked"]')?.textContent || "false";
                const descriptionVal = containerChunk?.querySelector('item[name="Description"]')?.textContent || "";
                const instanceGuid = containerChunk?.querySelector('item[name="InstanceGuid"]')?.textContent;

                // Parse the ARGB color
                const colorItem = containerChunk?.querySelector('item[name="SwatchColor"] ARGB');
                const [alpha, red, green, blue] = (colorItem?.textContent || "255;255;255;255")
                    .split(";")
                    .map((v) => parseInt(v));

                // Convert to hex for the color input
                const hexColor = `#${red.toString(16).padStart(2, "0")}${green.toString(16).padStart(2, "0")}${blue.toString(16).padStart(2, "0")}`;

                if (instanceGuid) {
                    sectionGuids.colorSwatches.add(instanceGuid);
                }

                const div = document.createElement("div");
                div.className = "componentPanel colorSwatchPanel";
                div.dataset.guid = instanceGuid;
                div.innerHTML = `
            <h3 class="collapsibleHeader">Color Swatch ${index + 1} (${nameVal})</h3>
            <div class="collapsibleContent">
                <label>Name</label>
                <input type="text" class="name" value="${nameVal}">
                <label>NickName</label>
                <input type="text" class="nickname" value="${nicknameVal}">
                <label>Locked</label>
                <input type="checkbox" class="locked" ${lockedVal.toLowerCase() === "true" ? "checked" : ""}>
                <label>Description</label>
                <textarea class="description" rows="4">${descriptionVal}</textarea>
                <label>Color</label>
                <div class="colorInputGroup">
                    <input type="color" class="colorPicker" value="${hexColor}">
                    <input type="range" class="alphaSlider" min="0" max="255" value="${alpha}">
                    <span class="alphaValue">${alpha}</span>
                </div>
            </div>
        `;

                // Add event listeners for color and alpha changes
                const colorPicker = div.querySelector(".colorPicker");
                const alphaSlider = div.querySelector(".alphaSlider");
                const alphaValue = div.querySelector(".alphaValue");

                colorPicker.addEventListener("input", function () {
                    const hex = this.value;
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    const alpha = alphaSlider.value;
                    updateSwatchColor(containerChunk, alpha, r, g, b);
                });

                alphaSlider.addEventListener("input", function () {
                    alphaValue.textContent = this.value;
                    const hex = colorPicker.value;
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    updateSwatchColor(containerChunk, this.value, r, g, b);
                });

                colorSwatchContainer.appendChild(div);
            });
            attachCollapseFor(colorSwatchContainer);
        }

        // ----- SKECTSHES -----
        function populateSketchesList() {
            sectionGuids.sketches.clear();
            sketchesContainer.innerHTML = "";

            const sketchObjects = Array.from(xmlDoc.querySelectorAll('chunk[name="Object"]')).filter(
                (obj) => obj.querySelector('item[name="Name"]')?.textContent === "Sketch"
            );

            sketchObjects.forEach((sketchObj, index) => {
                const containerChunk = sketchObj.querySelector('chunk[name="Container"]');
                const instanceGuid = containerChunk?.querySelector('item[name="InstanceGuid"]')?.textContent;

                if (instanceGuid) {
                    sectionGuids.sketches.add(instanceGuid);
                }

                // Get sketch properties
                const sketchPropertiesChunk = containerChunk.querySelector(
                    'chunk[name="Attributes"] chunk[name="SketchProperties"]'
                );

                const rawColorVal = sketchPropertiesChunk?.querySelector('item[name="Color"]')?.textContent || "";
                const colorVal = rawColorVal.includes(";") ? argbToHex(rawColorVal) : rawColorVal;
                const widthVal = sketchPropertiesChunk?.querySelector('item[name="Width"]')?.textContent || "";
                const patternVal = sketchPropertiesChunk?.querySelector('item[name="Pattern"]')?.textContent || "";

                // Parse all Mark chunks for vertices
                const markChunks = containerChunk.querySelectorAll('chunk[name="Mark"]');
                let curves = [];
                markChunks.forEach((markChunk) => {
                    const vertexItems = markChunk.querySelectorAll('item[name="V"]');
                    let curve = [];
                    vertexItems.forEach((item) => {
                        const xElem = item.querySelector("X");
                        const yElem = item.querySelector("Y");
                        if (xElem && yElem) {
                            curve.push({
                                x: parseFloat(xElem.textContent),
                                y: parseFloat(yElem.textContent)
                            });
                        }
                    });
                    if (curve.length > 0) {
                        curves.push(curve);
                    }
                });

                const div = document.createElement("div");
                div.className = "componentPanel sketchPanel";
                div.dataset.guid = instanceGuid;
                div.innerHTML = `
            <h3 class="collapsibleHeader">Sketch ${index + 1}</h3>
            <div class="collapsibleContent">
                <label>Color</label>
                <input type="color" class="color" value="${colorVal}">
                <label>Width</label>
                <input type="number" class="width" value="${widthVal}" min="0.1" max="10" step="0.1">
                <label>Pattern</label>
                <select class="pattern">
                    <option value="0" ${patternVal === "0" ? "selected" : ""}>Solid</option>
                    <option value="1" ${patternVal === "1" ? "selected" : ""}>Dashed</option>
                    <option value="2" ${patternVal === "2" ? "selected" : ""}>Dotted</option>
                </select>
                <div class="curvePreview" data-curves='${JSON.stringify(curves)}'></div>
            </div>
        `;

                // Add event listeners for the inputs
                const inputs = div.querySelectorAll("input, select");
                const colorInput = div.querySelector("input.color");
                inputs.forEach((input) => {
                    input.addEventListener("change", function () {
                        const className = this.className.split(" ")[0];
                        const value = this.value;
                        const sketchPropertiesChunk = containerChunk.querySelector(
                            'chunk[name="Attributes"] chunk[name="SketchProperties"]'
                        );
                        if (sketchPropertiesChunk) {
                            const item = sketchPropertiesChunk.querySelector(
                                `item[name="${className.charAt(0).toUpperCase() + className.slice(1)}"]`
                            );
                            if (item) {
                                // If this is a color input, convert the hex value to ARGB.
                                if (this.type === "color") {
                                    const r = parseInt(value.slice(1, 3), 16);
                                    const g = parseInt(value.slice(3, 5), 16);
                                    const b = parseInt(value.slice(5, 7), 16);
                                    item.textContent = `255;${r};${g};${b}`;
                                } else {
                                    item.textContent = value;
                                }
                            }
                        }
                    });
                });

                sketchesContainer.appendChild(div);
            });
            attachCollapseFor(sketchesContainer);
        }

        // ----- SCRIBBLES -----
        function populateScribblesList() {
            sectionGuids.scribbles.clear();
            scribblesContainer.innerHTML = "";

            const scribbleObjects = Array.from(xmlDoc.querySelectorAll('chunk[name="Object"]')).filter(
                (obj) => obj.querySelector('item[name="Name"]')?.textContent === "Scribble"
            );

            scribbleObjects.forEach((scribbleObj, index) => {
                const containerChunk = scribbleObj.querySelector('chunk[name="Container"]');
                const instanceGuid = containerChunk?.querySelector('item[name="InstanceGuid"]')?.textContent;

                if (instanceGuid) {
                    sectionGuids.scribbles.add(instanceGuid);
                }

                const nameVal = containerChunk?.querySelector('item[name="Name"]')?.textContent || "";
                const nicknameVal = containerChunk?.querySelector('item[name="NickName"]')?.textContent || "";
                const descriptionVal = containerChunk?.querySelector('item[name="Description"]')?.textContent || "";
                const textVal = containerChunk?.querySelector('item[name="Text"]')?.textContent || "";
                const fontVal = containerChunk?.querySelector('item[name="Font"]')?.textContent || "";
                const sizeVal = containerChunk?.querySelector('item[name="Size"]')?.textContent || "";
                const boldVal = containerChunk?.querySelector('item[name="Bold"]')?.textContent === "true";
                const italicVal = containerChunk?.querySelector('item[name="Italic"]')?.textContent === "true";

                const div = document.createElement("div");
                div.className = "componentPanel scribblePanel";
                div.dataset.guid = instanceGuid;
                div.innerHTML = `
      <h3 class="collapsibleHeader">Scribble ${index + 1} (${nameVal})</h3>
      <div class="collapsibleContent">
        <label>Name</label>
        <input type="text" class="name" value="${nameVal}">
        <label>NickName</label>
        <input type="text" class="nickname" value="${nicknameVal}">
        <label>Description</label>
        <textarea class="description" rows="4">${descriptionVal}</textarea>
        <label>Text</label>
        <textarea class="text" rows="4">${textVal}</textarea>
        <label>Font</label>
        <input type="text" class="font" value="${fontVal}">
        <label>Size</label>
        <input type="number" class="size" value="${sizeVal}" min="1" max="100" step="1">
        <div style="margin-top: 10px;">
          <label style="display: inline;">
            <input type="checkbox" class="bold" ${boldVal ? "checked" : ""}> Bold
          </label>
          <label style="display: inline; margin-left: 20px;">
            <input type="checkbox" class="italic" ${italicVal ? "checked" : ""}> Italic
          </label>
        </div>
      </div>
    `;

                // Add generic change listeners for all inputs/textarea for XML updates
                const inputs = div.querySelectorAll("input, textarea");
                inputs.forEach((input) => {
                    input.addEventListener("change", function () {
                        const className = this.className.split(" ")[0];
                        const value = this.type === "checkbox" ? this.checked : this.value;
                        // Update the XML
                        const item = containerChunk.querySelector(
                            `item[name="${className.charAt(0).toUpperCase() + className.slice(1)}"]`
                        );
                        if (item) {
                            if (this.type === "checkbox") {
                                item.textContent = value.toString();
                            } else {
                                item.textContent = value;
                            }
                        }
                    });

                    // Add live update listeners for visual properties
                    const eventType = input.type === "checkbox" ? "change" : "input";
                    input.addEventListener(eventType, function () {
                        const instanceGuid = this.closest(".scribblePanel").dataset.guid;
                        const svgGroup = svgElement.querySelector(`g[data-guid="${instanceGuid}"]`);
                        if (svgGroup) {
                            const svgText = svgGroup.querySelector("text");
                            if (svgText) {
                                // Update SVG text properties based on input type
                                switch (this.className) {
                                    case "text":
                                        svgText.textContent = this.value;
                                        break;
                                    case "font":
                                        svgText.style.fontFamily = this.value;
                                        break;
                                    case "size":
                                        svgText.style.fontSize = `${this.value}px`;
                                        break;
                                    case "bold":
                                        svgText.style.fontWeight = this.checked ? "bold" : "normal";
                                        break;
                                    case "italic":
                                        svgText.style.fontStyle = this.checked ? "italic" : "normal";
                                        break;
                                }
                            }
                        }
                    });
                });

                scribblesContainer.appendChild(div);
            });

            attachCollapseFor(scribblesContainer);
        }

        const skipItems = ["SwatchColor", "Scribble", "Sketch", "C# Script", "GhPython Script", "Gene Pool"];
        const skippedNames = ["Curve", "Mesh", "Brep"];

        // ----- GENERAL -----
        function populateGeneralComponentsList() {
            sectionGuids.general.clear();
            generalContainer.innerHTML = "";

            // Get all components that don't belong to other sections
            const allComponents = Array.from(xmlDoc.querySelectorAll('chunk[name="Object"]'));

            allComponents.forEach((componentObj) => {
                const containerChunk = componentObj.querySelector('chunk[name="Container"]');
                if (!containerChunk) return;

                const instanceGuid = containerChunk.querySelector('item[name="InstanceGuid"]')?.textContent;
                if (!instanceGuid) return;

                const itemName = componentObj.querySelector('item[name="Name"]')?.textContent;
                // Skip if the item name is in the skipItems list
                if (skipItems.includes(itemName)) return;

                const nameVal = containerChunk.querySelector('item[name="Name"]')?.textContent || "";
                const nicknameVal = containerChunk.querySelector('item[name="NickName"]')?.textContent || "";
                const lockedVal = containerChunk?.querySelector('item[name="Locked"]')?.textContent || "false";
                const hiddenVal = containerChunk?.querySelector('item[name="Hidden"]')?.textContent || "false";
                const descriptionVal = containerChunk.querySelector('item[name="Description"]')?.textContent || "";

                // Check if this component belongs to any other section
                const belongsToOtherSection =
                    sectionGuids.placeHolders.has(instanceGuid) ||  // Add placeholders check here
                    sectionGuids.sliders.has(instanceGuid) ||
                    sectionGuids.toggles.has(instanceGuid) ||
                    sectionGuids.panels.has(instanceGuid) ||
                    sectionGuids.expressions.has(instanceGuid) ||
                    sectionGuids.valueLists.has(instanceGuid) ||
                    sectionGuids.persistentData.has(instanceGuid) ||
                    sectionGuids.python.has(instanceGuid) ||
                    sectionGuids.csharp.has(instanceGuid) ||
                    sectionGuids.colorSwatches.has(instanceGuid) ||
                    sectionGuids.scribbles.has(instanceGuid);

                if (!belongsToOtherSection) {
                    sectionGuids.general.add(instanceGuid);

                    const div = document.createElement("div");
                    div.className = "componentPanel generalPanel";
                    div.dataset.guid = instanceGuid;
                    div.innerHTML = `
                <h3 class="collapsibleHeader">Component: ${nameVal} (${nicknameVal})</h3>
                <div class="collapsibleContent">
                    <label>Name</label>
                    <input type="text" class="name" value="${nameVal}">
                    <label>NickName</label>
                    <input type="text" class="nickname" value="${nicknameVal}">
                    <label>Locked</label>
                    <input type="checkbox" class="locked" ${lockedVal.toLowerCase() === "true" ? "checked" : ""} readonly>
                    <label>Hidden</label>
                    <input type="checkbox" class="hidden" ${hiddenVal.toLowerCase() === "true" ? "checked" : ""} readonly>
                    <label>Description</label>
                    <textarea class="description" rows="4" >${descriptionVal}</textarea>
                </div>
            `;
                    generalContainer.appendChild(div);
                }
            });
            attachCollapseFor(generalContainer);
        }

        // ----- SLIDERS -----
        function populateSlidersList() {
            sectionGuids.sliders.clear(); // Clear existing GUIDs
            sliderObjects = Array.from(xmlDoc.querySelectorAll('chunk[name="Object"]')).filter((obj) =>
                obj.querySelector('chunk[name="Slider"]')
            );
            slidersContainer.innerHTML = "";

            sliderObjects.forEach((sliderObj, index) => {
                const containerChunk = sliderObj.querySelector('chunk[name="Container"]');
                const instanceGuid = containerChunk?.querySelector('item[name="InstanceGuid"]')?.textContent;
                if (instanceGuid) {
                    sectionGuids.sliders.add(instanceGuid);
                }
                const sliderChunk = sliderObj.querySelector('chunk[name="Slider"]');

                const nameVal = containerChunk?.querySelector('item[name="Name"]')?.textContent || "";
                const nicknameVal = containerChunk?.querySelector('item[name="NickName"]')?.textContent || "";
                const lockedVal = containerChunk?.querySelector('item[name="Locked"]')?.textContent || "false";
                const descriptionVal = containerChunk?.querySelector('item[name="Description"]')?.textContent || "";
                const digitsVal = sliderChunk?.querySelector('item[name="Digits"]')?.textContent || "";
                const maxVal = sliderChunk?.querySelector('item[name="Max"]')?.textContent || "";
                const minVal = sliderChunk?.querySelector('item[name="Min"]')?.textContent || "";
                const valueVal = sliderChunk?.querySelector('item[name="Value"]')?.textContent || "";

                const div = document.createElement("div");
                div.className = "componentPanel sliderPanel";
                div.dataset.index = index;
                div.dataset.guid = instanceGuid; // Add GUID to the panel
                div.innerHTML = `
          <h3 class="collapsibleHeader">Slider ${index + 1} (${nameVal})</h3>
          <div class="collapsibleContent">
            <label>Name</label>
            <input type="text" class="name" value="${nameVal}">
            <label>NickName</label>
            <input type="text" class="nickname" value="${nicknameVal}">
            <label>Locked</label>
            <input type="checkbox" class="locked" ${lockedVal.toLowerCase() === "true" ? "checked" : ""}>
            <label>Description</label>
            <textarea class="description" rows="4">${descriptionVal}</textarea>
            <label>Digits</label>
            <input type="number" class="digits" value="${digitsVal}">
            <label>Max</label>
            <input type="number" step="any" class="max" value="${maxVal}">
            <label>Min</label>
            <input type="number" step="any" class="min" value="${minVal}">
            <label>Value</label>
            <input type="number" step="any" class="value" value="${valueVal}">
          </div>
        `;
                slidersContainer.appendChild(div);
            });
            attachCollapseFor(slidersContainer);
        }

        // ----- BOOLEAN TOGGLES -----
        function populateTogglesList() {
            sectionGuids.toggles.clear(); // Clear existing GUIDs
            toggleObjects = Array.from(xmlDoc.querySelectorAll('chunk[name="Object"]')).filter((obj) => {
                const container = obj.querySelector('chunk[name="Container"]');
                return container && container.querySelector('item[name="ToggleValue"]');
            });
            togglesContainer.innerHTML = "";

            toggleObjects.forEach((toggleObj, index) => {
                const containerChunk = toggleObj.querySelector('chunk[name="Container"]');
                const instanceGuid = containerChunk?.querySelector('item[name="InstanceGuid"]')?.textContent;
                if (instanceGuid) {
                    sectionGuids.toggles.add(instanceGuid);
                }
                const nameVal = containerChunk?.querySelector('item[name="Name"]')?.textContent || "";
                const nicknameVal = containerChunk?.querySelector('item[name="NickName"]')?.textContent || "";
                const lockedVal = containerChunk?.querySelector('item[name="Locked"]')?.textContent || "false";
                const descriptionVal = containerChunk?.querySelector('item[name="Description"]')?.textContent || "";
                const toggleValueVal =
                    containerChunk?.querySelector('item[name="ToggleValue"]')?.textContent.trim() || "false";

                const div = document.createElement("div");
                div.className = "componentPanel togglePanel";
                div.dataset.index = index;
                div.dataset.guid = instanceGuid; // Add GUID to the panel
                div.innerHTML = `
          <h3 class="collapsibleHeader">Toggle ${index + 1} (${nameVal})</h3>
          <div class="collapsibleContent">
            <label>Name</label>
            <input type="text" class="name" value="${nameVal}">
            <label>NickName</label>
            <input type="text" class="nickname" value="${nicknameVal}">
            <label>Locked</label>
            <input type="checkbox" class="locked" ${lockedVal.toLowerCase() === "true" ? "checked" : ""}>
            <label>Description</label>
            <textarea class="description" rows="4">${descriptionVal}</textarea>
            <label>Toggle Value</label>
            <input type="checkbox" class="toggleValue" ${toggleValueVal.toLowerCase() === "true" ? "checked" : ""}>
          </div>
        `;
                togglesContainer.appendChild(div);
            });
            attachCollapseFor(togglesContainer);
        }

        // ----- PANELS -----
        function populatePanelsList() {
            sectionGuids.panels.clear(); // Clear existing GUIDs
            panelObjects = Array.from(xmlDoc.querySelectorAll('chunk[name="Object"]')).filter((obj) => {
                const container = obj.querySelector('chunk[name="Container"]');
                return container && container.querySelector('item[name="UserText"]');
            });
            panelsContainer.innerHTML = "";

            panelObjects.forEach((panelObj, index) => {
                const containerChunk = panelObj.querySelector('chunk[name="Container"]');
                const instanceGuid = containerChunk?.querySelector('item[name="InstanceGuid"]')?.textContent;
                if (instanceGuid) {
                    sectionGuids.panels.add(instanceGuid);
                }
                const nameVal = containerChunk?.querySelector('item[name="Name"]')?.textContent || "";
                const nicknameVal = containerChunk?.querySelector('item[name="NickName"]')?.textContent || "";
                const lockedVal = containerChunk?.querySelector('item[name="Locked"]')?.textContent || "false";
                const descriptionVal = containerChunk?.querySelector('item[name="Description"]')?.textContent || "";
                const userTextVal = containerChunk?.querySelector('item[name="UserText"]')?.textContent || "";

                const div = document.createElement("div");
                div.className = "componentPanel panelPanel";
                div.dataset.index = index;
                div.dataset.guid = instanceGuid; // Add GUID to the panel
                div.innerHTML = `
          <h3 class="collapsibleHeader">Panel ${index + 1} (${nameVal})</h3>
          <div class="collapsibleContent">
            <label>Name</label>
            <input type="text" class="name" value="${nameVal}">
            <label>NickName</label>
            <input type="text" class="nickname" value="${nicknameVal}">
            <label>Locked</label>
            <input type="checkbox" class="locked" ${lockedVal.toLowerCase() === "true" ? "checked" : ""}>
            <label>Description</label>
            <textarea class="description" rows="4">${descriptionVal}</textarea>
            <label>UserText</label>
            <textarea class="userText" rows="4">${userTextVal}</textarea>
          </div>
        `;
                panelsContainer.appendChild(div);
            });
            attachCollapseFor(panelsContainer);
        }

        // ----- EXPRESSIONS -----
        function populateExpressionsList() {
            sectionGuids.expressions.clear();
            // Exclude any objects that are value lists (they have a ListCount item)
            expressionObjects = Array.from(xmlDoc.querySelectorAll('chunk[name="Object"]')).filter((obj) => {
                const container = obj.querySelector('chunk[name="Container"]');
                return (
                    container &&
                    container.querySelector('item[name="Expression"]') &&
                    !container.querySelector('item[name="ListCount"]')
                );
            });
            expressionsContainer.innerHTML = "";

            expressionObjects.forEach((exprObj, index) => {
                const containerChunk = exprObj.querySelector('chunk[name="Container"]');
                const instanceGuid = containerChunk?.querySelector('item[name="InstanceGuid"]')?.textContent;
                if (instanceGuid) {
                    sectionGuids.expressions.add(instanceGuid);
                }
                const nameVal = containerChunk?.querySelector('item[name="Name"]')?.textContent || "";
                const nicknameVal = containerChunk?.querySelector('item[name="NickName"]')?.textContent || "";
                const lockedVal = containerChunk?.querySelector('item[name="Locked"]')?.textContent || "false";
                const descriptionVal = containerChunk?.querySelector('item[name="Description"]')?.textContent || "";
                // Get the full expression text without any truncation
                const expressionVal = containerChunk?.querySelector('item[name="Expression"]')?.textContent || "";

                const div = document.createElement("div");
                div.className = "componentPanel expressionPanel";
                div.dataset.index = index;
                div.dataset.guid = instanceGuid;
                div.innerHTML = `
            <h3 class="collapsibleHeader">Expression ${index + 1} (${nameVal})</h3>
            <div class="collapsibleContent">
                <label>Name</label>
                <input type="text" class="name" value="${nameVal}">
                <label>NickName</label>
                <input type="text" class="nickname" value="${nicknameVal}">
                <label>Locked</label>
                <input type="checkbox" class="locked" ${lockedVal.toLowerCase() === "true" ? "checked" : ""}>
                <label>Description</label>
                <textarea class="description" rows="4">${descriptionVal}</textarea>
                <label>Expression</label>
                <input type="text" class="expression" value="${expressionVal.replace(/"/g, '&quot;')}">
            </div>
        `;
                expressionsContainer.appendChild(div);
            });
            attachCollapseFor(expressionsContainer);
        }

        // ----- VALUE LISTS -----
        function populateValueListsList() {
            sectionGuids.valueLists.clear(); // Clear existing GUIDs
            // A Value List is identified by a Container that includes a ListCount item.
            valueListObjects = Array.from(xmlDoc.querySelectorAll('chunk[name="Object"]')).filter((obj) => {
                const container = obj.querySelector('chunk[name="Container"]');
                return container && container.querySelector('item[name="ListCount"]');
            });
            valueListsContainer.innerHTML = "";

            valueListObjects.forEach((valListObj, index) => {
                const containerChunk = valListObj.querySelector('chunk[name="Container"]');
                const instanceGuid = containerChunk?.querySelector('item[name="InstanceGuid"]')?.textContent;
                if (instanceGuid) {
                    sectionGuids.valueLists.add(instanceGuid);
                }
                const nameVal = containerChunk?.querySelector('item[name="Name"]')?.textContent || "";
                const nicknameVal = containerChunk?.querySelector('item[name="NickName"]')?.textContent || "";
                const lockedVal = containerChunk?.querySelector('item[name="Locked"]')?.textContent || "false";
                const descriptionVal = containerChunk?.querySelector('item[name="Description"]')?.textContent || "";

                // Get all ListItem chunks from within this container
                const listItemChunks = Array.from(containerChunk.querySelectorAll('chunk[name="ListItem"]'));

                const div = document.createElement("div");
                div.className = "componentPanel valueListPanel";
                div.dataset.index = index;
                div.dataset.guid = instanceGuid; // Add GUID to the panel
                div.innerHTML = `
      <h3 class="collapsibleHeader">Value List ${index + 1} (${nameVal})</h3>
      <div class="collapsibleContent">
        <label>Name</label>
        <input type="text" class="name" value="${nameVal}">
        <label>NickName</label>
        <input type="text" class="nickname" value="${nicknameVal}">
        <label>Locked</label>
        <input type="checkbox" class="locked" ${lockedVal.toLowerCase() === "true" ? "checked" : ""}>
        <label>Description</label>
        <textarea class="description" rows="4">${descriptionVal}</textarea>
        <label>List Items</label>
        <table class="listItemsTable">
          <thead>
            <tr>
              <th>Item Name</th>
              <th>Expression</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    `;
                const tbody = div.querySelector("tbody");
                listItemChunks.forEach((itemChunk, liIndex) => {
                    const itemName = itemChunk.querySelector('item[name="Name"]')?.textContent || "";
                    const itemExpression = itemChunk.querySelector('item[name="Expression"]')?.textContent || "";
                    const row = document.createElement("tr");
                    row.dataset.index = liIndex;
                    row.innerHTML = `
        <td><input type="text" class="itemName" value="${itemName}"></td>
        <td><input type="text" class="itemExpression" value="${itemExpression}"></td>
      `;
                    tbody.appendChild(row);
                });
                valueListsContainer.appendChild(div);
            });
            attachCollapseFor(valueListsContainer);
        }

        // ----- PERSISTENT DATA -----
        const allowedTypes = ["gh_string", "gh_double", "gh_int32", "gh_bool"];

        function getPersistentItemsFromContainer(containerChunk) {
            const pdChunks = containerChunk.querySelectorAll('chunk[name="PersistentData"]');
            let items = [];
            pdChunks.forEach((pdChunk) => {
                const branchChunks = pdChunk.querySelectorAll('chunk[name="Branch"]');
                branchChunks.forEach((branchChunk) => {
                    const itemNodes = branchChunk.querySelectorAll("item");
                    itemNodes.forEach((itemNode) => {
                        const itemName = itemNode.getAttribute("name");
                        // Skip unwanted items.
                        if (itemName === "null_string" || itemName === "Count" || itemName === "Path") return;
                        const typeName = itemNode.getAttribute("type_name");
                        if (allowedTypes.includes(typeName)) {
                            items.push(itemNode);
                        }
                    });
                });
            });
            return items;
        }

        function populatePersistentDataList() {
            sectionGuids.persistentData.clear(); // Clear existing GUIDs
            // Get all Container chunks that have at least one descendant PersistentData chunk.
            const containersWithPD = Array.from(xmlDoc.querySelectorAll('chunk[name="Container"]')).filter(
                (container) => {
                    const instanceGuid = container.querySelector('item[name="InstanceGuid"]')?.textContent;
                    return container.querySelector('chunk[name="PersistentData"]') && !sectionGuids.placeHolders.has(instanceGuid);
                }
            );
            persistentDataContainer.innerHTML = "";

            // Also store these containers globally for saving.
            persistentDataContainers = containersWithPD;

            containersWithPD.forEach((containerChunk, index) => {
                // Retrieve container's metadata.
                const instanceGuid = containerChunk?.querySelector('item[name="InstanceGuid"]')?.textContent;
                if (instanceGuid) {
                    sectionGuids.persistentData.add(instanceGuid);
                }
                const pdName = containerChunk.querySelector('item[name="Name"]')?.textContent || "";
                const pdNickname = containerChunk.querySelector('item[name="NickName"]')?.textContent || "";
                const lockedVal = containerChunk?.querySelector('item[name="Locked"]')?.textContent || "false";
                const hiddenVal = containerChunk?.querySelector('item[name="Hidden"]')?.textContent || "false";
                const pdDescription = containerChunk.querySelector('item[name="Description"]')?.textContent || "";

                // Build the panel.
                const div = document.createElement("div");
                div.className = "componentPanel persistentDataPanel";
                div.dataset.index = index;
                div.dataset.guid = instanceGuid; // Add GUID to the panel
                div.innerHTML = `
      <h3 class="collapsibleHeader">Persistent Data (${pdName})</h3>
      <div class="collapsibleContent">
        <label>Name</label>
        <input type="text" class="pdName" value="${pdName}">
        <label>NickName</label>
        <input type="text" class="pdNickname" value="${pdNickname}">
        <label>Locked</label>
        <input type="checkbox" class="locked" ${lockedVal.toLowerCase() === "true" ? "checked" : ""}>
        <label>Hidden</label>
        <input type="checkbox" class="hidden" ${hiddenVal.toLowerCase() === "true" ? "checked" : ""}>
        <label>Description</label>
        <textarea class="pdDescription" rows="4">${pdDescription}</textarea>
        <table class="persistentDataTable">
          <thead>
            <tr>
              <th>Parameter</th>
              <th>Value</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    `;
                const tbody = div.querySelector("tbody");

                // Get allowed persistent data items from this container.
                const items = getPersistentItemsFromContainer(containerChunk);

                // For each allowed persistent data item, create a table row.
                items.forEach((itemNode) => {
                    const itemName = itemNode.getAttribute("NickName") || itemNode.getAttribute("name");
                    const value = itemNode.textContent;
                    let inputField = "";
                    const typeName = itemNode.getAttribute("type_name");
                    if (typeName === "gh_bool") {
                        inputField = `<input type="checkbox" class="persistentValue" ${value.trim().toLowerCase() === "true" ? "checked" : ""}>`;
                    } else if (typeName === "gh_double" || typeName === "gh_int32") {
                        inputField = `<input type="number" step="any" class="persistentValue" value="${value}">`;
                    } else {
                        inputField = `<input type="text" class="persistentValue" value="${value}">`;
                    }
                    const tr = document.createElement("tr");
                    tr.innerHTML = `<td>${itemName}</td><td>${inputField}</td>`;
                    tbody.appendChild(tr);
                });

                persistentDataContainer.appendChild(div);
            });
            attachCollapseFor(persistentDataContainer);
        }

        // ----- C# COMPONENTS -----
        function populateCSharpComponentList() {
            sectionGuids.csharp.clear();
            csharpContainer.innerHTML = "";

            // Filter to identify C# components by their name
            csharpObjects = Array.from(xmlDoc.querySelectorAll('chunk[name="Object"]')).filter((obj) => {
                const nameItem = obj.querySelector('item[name="Name"]');
                return nameItem?.textContent === "C# Script";
            });

            csharpObjects.forEach((csObj, index) => {
                const container = csObj.querySelector('chunk[name="Container"]');
                const instanceGuid = container?.querySelector('item[name="InstanceGuid"]')?.textContent;
                if (instanceGuid) {
                    sectionGuids.csharp.add(instanceGuid);
                }

                // Basic properties
                const nameVal = container?.querySelector('item[name="Name"]')?.textContent || "";
                const nicknameVal = container?.querySelector('item[name="NickName"]')?.textContent || "";
                const lockedVal = container?.querySelector('item[name="Locked"]')?.textContent || "false";
                const hiddenVal = container?.querySelector('item[name="Hidden"]')?.textContent || "false";
                const descriptionVal = container?.querySelector('item[name="Description"]')?.textContent || "";

                // Get reference count and references
                const referenceCount = parseInt(
                    container?.querySelector('item[name="ReferenceCount"]')?.textContent || "0"
                );
                const references = Array.from(container?.querySelectorAll('item[name="Reference"]') || [])
                    .map((ref) => ref.textContent || "")
                    .filter((ref) => ref.trim() !== "");

                // Check for existence of code-related items
                const additionalSourceItem = container?.querySelector('item[name="AdditionalSource"]');
                const scriptSourceItem = container?.querySelector('item[name="ScriptSource"]');
                const usingSourceItem = container?.querySelector('item[name="UsingSource"]');

                let codeFieldsHtml = "";

                // Only add fields that exist in the XML
                if (usingSourceItem) {
                    codeFieldsHtml += `
        <label>UsingSource</label>
        <textarea class="usingSource" rows="3">${usingSourceItem.textContent || ""}</textarea>
      `;
                }

                if (additionalSourceItem) {
                    codeFieldsHtml += `
        <label>AdditionalSource</label>
        <textarea class="additionalSource" rows="3">${additionalSourceItem.textContent || ""}</textarea>
      `;
                }

                if (scriptSourceItem) {
                    codeFieldsHtml += `
        <label>ScriptSource</label>
        <textarea class="scriptSource" rows="5">${scriptSourceItem.textContent || ""}</textarea>
      `;
                }

                // Add references section if there are any
                if (referenceCount > 0) {
                    codeFieldsHtml += `
        <label>Reference</label>
        <div class="references-container">
          ${references
                            .map(
                                (ref, idx) => `
            <div class="reference-item">
              <input type="text" class="reference" data-index="${idx}" value="${ref}">
            </div>
          `
                            )
                            .join("")}
        </div>
      `;
                }

                const div = document.createElement("div");
                div.className = "componentPanel csharpPanel";
                div.dataset.index = index;
                div.dataset.guid = instanceGuid;
                div.innerHTML = `
      <h3 class="collapsibleHeader">C# Script (${nameVal})</h3>
      <div class="collapsibleContent">
        <label>Name</label>
        <input type="text" class="name" value="${nameVal}">
        <label>NickName</label>
        <input type="text" class="nickname" value="${nicknameVal}">
        <label>Locked</label>
        <input type="checkbox" class="locked" ${lockedVal.toLowerCase() === "true" ? "checked" : ""}>
        <label>Hidden</label>
        <input type="checkbox" class="hidden" ${hiddenVal.toLowerCase() === "true" ? "checked" : ""}>
        <label>Description</label>
        <textarea class="description" rows="4">${descriptionVal}</textarea>
        ${codeFieldsHtml}
      </div>
    `;
                csharpContainer.appendChild(div);
            });
            attachCollapseFor(csharpContainer);
        }

        // ----- PYTHON COMPONENTS -----
        function populatePythonComponentList() {
            sectionGuids.python.clear();
            pythonContainer.innerHTML = "";

            pythonObjects = Array.from(xmlDoc.querySelectorAll('chunk[name="Object"]')).filter((obj) => {
                const nameItem = obj.querySelector('item[name="Name"]');
                return nameItem?.textContent === "GhPython Script";
            });

            pythonObjects.forEach((pyObj, index) => {
                const container = pyObj.querySelector('chunk[name="Container"]');
                const instanceGuid = container?.querySelector('item[name="InstanceGuid"]')?.textContent;
                if (instanceGuid) {
                    sectionGuids.python.add(instanceGuid);
                }

                // Basic properties
                const nameVal = container?.querySelector('item[name="Name"]')?.textContent || "";
                const nicknameVal = container?.querySelector('item[name="NickName"]')?.textContent || "";
                const lockedVal = container?.querySelector('item[name="Locked"]')?.textContent || "false";
                const hiddenVal = container?.querySelector('item[name="Hidden"]')?.textContent || "false";
                const descriptionVal = container?.querySelector('item[name="Description"]')?.textContent || "";

                // Check for existence of CodeInput
                const codeInputItem = container?.querySelector('item[name="CodeInput"]');

                let codeFieldHtml = "";
                if (codeInputItem) {
                    codeFieldHtml = `
        <label>CodeInput</label>
        <textarea class="codeInput" rows="5">${codeInputItem.textContent || ""}</textarea>
      `;
                }

                const div = document.createElement("div");
                div.className = "componentPanel pythonPanel";
                div.dataset.index = index;
                div.dataset.guid = instanceGuid;
                div.innerHTML = `
      <h3 class="collapsibleHeader">Python Script (${nameVal})</h3>
      <div class="collapsibleContent">
        <label>Name</label>
        <input type="text" class="name" value="${nameVal}">
        <label>NickName</label>
        <input type="text" class="nickname" value="${nicknameVal}">
        <label>Locked</label>
        <input type="checkbox" class="locked" ${lockedVal.toLowerCase() === "true" ? "checked" : ""}>
        <label>Hidden</label>
        <input type="checkbox" class="hidden" ${hiddenVal.toLowerCase() === "true" ? "checked" : ""}>
        <label>Description</label>
        <textarea class="description" rows="4">${descriptionVal}</textarea>
        ${codeFieldHtml}
      </div>
    `;
                pythonContainer.appendChild(div);
            });
            attachCollapseFor(pythonContainer);
        }

        // --- SAVE FILE ---
        saveBtn.addEventListener("click", () => {
            if (!xmlDoc) {
                alert("No file loaded!");
                return;
            }
            //
            // Helper function to update or add a locked item in a container chunk.
            function updateLockedItem(containerChunk, lockedValue) {
                let lockedItem = containerChunk.querySelector('item[name="Locked"]');
                if (lockedItem) {
                    lockedItem.textContent = lockedValue;
                } else {
                    lockedItem = xmlDoc.createElement("item");
                    lockedItem.setAttribute("name", "Locked");
                    lockedItem.setAttribute("type_name", "gh_bool");
                    lockedItem.setAttribute("type_code", "1");
                    lockedItem.textContent = lockedValue;
                    let itemsElement = containerChunk.querySelector("items");
                    if (!itemsElement) {
                        itemsElement = xmlDoc.createElement("items");
                        itemsElement.setAttribute("count", "0");
                        containerChunk.appendChild(itemsElement);
                    }
                    itemsElement.appendChild(lockedItem);
                    let count = parseInt(itemsElement.getAttribute("count") || "0", 10);
                    itemsElement.setAttribute("count", (count + 1).toString());
                }
            }

            // Helper function to update or add a locked item in a container chunk.
            function updateHiddenItem(containerChunk, hiddenValue) {
                let hiddenItem = containerChunk.querySelector('item[name="Hidden"]');
                if (hiddenItem) {
                    hiddenItem.textContent = hiddenValue;
                } else {
                    hiddenItem = xmlDoc.createElement("item");
                    hiddenItem.setAttribute("name", "Hidden");
                    hiddenItem.setAttribute("type_name", "gh_bool");
                    hiddenItem.setAttribute("type_code", "1");
                    hiddenItem.textContent = hiddenValue;
                    let itemsElement = containerChunk.querySelector("items");
                    if (!itemsElement) {
                        itemsElement = xmlDoc.createElement("items");
                        itemsElement.setAttribute("count", "0");
                        containerChunk.appendChild(itemsElement);
                    }
                    itemsElement.appendChild(hiddenItem);
                    let count = parseInt(itemsElement.getAttribute("count") || "0", 10);
                    itemsElement.setAttribute("count", (count + 1).toString());
                }
            }

            // Update Sliders
            const sliderPanels = slidersContainer.querySelectorAll(".sliderPanel");
            sliderPanels.forEach((panel, index) => {
                const nameVal = panel.querySelector("input.name").value;
                const nicknameVal = panel.querySelector("input.nickname").value;
                const lockedVal = panel.querySelector("input.locked").checked ? "true" : "false";
                const descriptionVal = panel.querySelector("textarea.description").value;
                const digitsVal = panel.querySelector("input.digits").value;
                const maxVal = panel.querySelector("input.max").value;
                const minVal = panel.querySelector("input.min").value;
                const valueVal = panel.querySelector("input.value").value;

                const sliderObj = sliderObjects[index];
                const containerChunk = sliderObj.querySelector('chunk[name="Container"]');
                const sliderChunk = sliderObj.querySelector('chunk[name="Slider"]');

                if (containerChunk) {
                    updateLockedItem(containerChunk, lockedVal);
                    const nameItem = containerChunk.querySelector('item[name="Name"]');
                    const nicknameItem = containerChunk.querySelector('item[name="NickName"]');
                    const descriptionItem = containerChunk.querySelector('item[name="Description"]');
                    if (nameItem) nameItem.textContent = nameVal;
                    if (nicknameItem) nicknameItem.textContent = nicknameVal;
                    if (descriptionItem) descriptionItem.textContent = descriptionVal;
                }
                if (sliderChunk) {
                    const digitsItem = sliderChunk.querySelector('item[name="Digits"]');
                    const maxItem = sliderChunk.querySelector('item[name="Max"]');
                    const minItem = sliderChunk.querySelector('item[name="Min"]');
                    const valueItem = sliderChunk.querySelector('item[name="Value"]');
                    if (digitsItem) digitsItem.textContent = digitsVal;
                    if (maxItem) maxItem.textContent = maxVal;
                    if (minItem) minItem.textContent = minVal;
                    if (valueItem) valueItem.textContent = valueVal;
                }
            });

            // Update Boolean Toggles
            const togglePanels = togglesContainer.querySelectorAll(".togglePanel");
            togglePanels.forEach((panel, index) => {
                const nameVal = panel.querySelector("input.name").value;
                const nicknameVal = panel.querySelector("input.nickname").value;
                const lockedVal = panel.querySelector("input.locked").checked ? "true" : "false";
                const descriptionVal = panel.querySelector("textarea.description").value;
                const toggleValueVal = panel.querySelector("input.toggleValue").checked ? "true" : "false";

                const toggleObj = toggleObjects[index];
                const containerChunk = toggleObj.querySelector('chunk[name="Container"]');
                if (containerChunk) {
                    updateLockedItem(containerChunk, lockedVal);
                    const nameItem = containerChunk.querySelector('item[name="Name"]');
                    const nicknameItem = containerChunk.querySelector('item[name="NickName"]');
                    const descriptionItem = containerChunk.querySelector('item[name="Description"]');
                    const toggleValueItem = containerChunk.querySelector('item[name="ToggleValue"]');
                    if (nameItem) nameItem.textContent = nameVal;
                    if (nicknameItem) nicknameItem.textContent = nicknameVal;
                    if (descriptionItem) descriptionItem.textContent = descriptionVal;
                    if (toggleValueItem) toggleValueItem.textContent = toggleValueVal;
                }
            });

            // Update Panels
            const panelPanels = panelsContainer.querySelectorAll(".panelPanel");
            panelPanels.forEach((panel, index) => {
                const nameVal = panel.querySelector("input.name").value;
                const nicknameVal = panel.querySelector("input.nickname").value;
                const lockedVal = panel.querySelector("input.locked").checked ? "true" : "false";
                const descriptionVal = panel.querySelector("textarea.description").value;
                const userTextVal = panel.querySelector("textarea.userText").value;

                const panelObj = panelObjects[index];
                const containerChunk = panelObj.querySelector('chunk[name="Container"]');
                if (containerChunk) {
                    updateLockedItem(containerChunk, lockedVal);
                    const nameItem = containerChunk.querySelector('item[name="Name"]');
                    const nicknameItem = containerChunk.querySelector('item[name="NickName"]');
                    const descriptionItem = containerChunk.querySelector('item[name="Description"]');
                    const userTextItem = containerChunk.querySelector('item[name="UserText"]');
                    if (nameItem) nameItem.textContent = nameVal;
                    if (nicknameItem) nicknameItem.textContent = nicknameVal;
                    if (descriptionItem) descriptionItem.textContent = descriptionVal;
                    if (userTextItem) userTextItem.textContent = userTextVal;
                }
            });

            // Update Expressions
            const expressionPanels = expressionsContainer.querySelectorAll(".expressionPanel");
            expressionPanels.forEach((panel, index) => {
                const nameVal = panel.querySelector("input.name").value;
                const nicknameVal = panel.querySelector("input.nickname").value;
                const lockedVal = panel.querySelector("input.locked").checked ? "true" : "false";
                const descriptionVal = panel.querySelector("textarea.description").value;
                const expressionVal = panel.querySelector("input.expression").value;

                const exprObj = expressionObjects[index];
                const containerChunk = exprObj.querySelector('chunk[name="Container"]');
                if (containerChunk) {
                    updateLockedItem(containerChunk, lockedVal);
                    const nameItem = containerChunk.querySelector('item[name="Name"]');
                    const nicknameItem = containerChunk.querySelector('item[name="NickName"]');
                    const descriptionItem = containerChunk.querySelector('item[name="Description"]');
                    const expressionItem = containerChunk.querySelector('item[name="Expression"]');
                    if (nameItem) nameItem.textContent = nameVal;
                    if (nicknameItem) nicknameItem.textContent = nicknameVal;
                    if (descriptionItem) descriptionItem.textContent = descriptionVal;
                    if (expressionItem) expressionItem.textContent = expressionVal;
                }
            });

            // Update Value Lists
            const valueListPanels = valueListsContainer.querySelectorAll(".valueListPanel");
            valueListPanels.forEach((panel, index) => {
                const nameVal = panel.querySelector("input.name").value;
                const nicknameVal = panel.querySelector("input.nickname").value;
                const descriptionVal = panel.querySelector("textarea.description").value;
                // Get locked value from value list panel UI
                const lockedVal = panel.querySelector("input.locked").checked ? "true" : "false";

                const valueListObj = valueListObjects[index];
                const containerChunk = valueListObj.querySelector('chunk[name="Container"]');
                if (containerChunk) {
                    updateLockedItem(containerChunk, lockedVal);
                    const nameItem = containerChunk.querySelector('item[name="Name"]');
                    const nicknameItem = containerChunk.querySelector('item[name="NickName"]');
                    const descriptionItem = containerChunk.querySelector('item[name="Description"]');
                    if (nameItem) nameItem.textContent = nameVal;
                    if (nicknameItem) nicknameItem.textContent = nicknameVal;
                    if (descriptionItem) descriptionItem.textContent = descriptionVal;
                }
                const listItemRows = panel.querySelectorAll("table.listItemsTable tbody tr");
                listItemRows.forEach((row, liIndex) => {
                    const itemNameVal = row.querySelector("input.itemName").value;
                    const itemExpressionVal = row.querySelector("input.itemExpression").value;
                    const listItemChunk = containerChunk.querySelectorAll('chunk[name="ListItem"]')[liIndex];
                    if (listItemChunk) {
                        const nameItem = listItemChunk.querySelector('item[name="Name"]');
                        const expressionItem = listItemChunk.querySelector('item[name="Expression"]');
                        if (nameItem) nameItem.textContent = itemNameVal;
                        if (expressionItem) expressionItem.textContent = itemExpressionVal;
                    }
                });
            });

            // Update Gene Pools
            const genePoolPanels = genePoolContainer.querySelectorAll(".genePoolPanel");
            genePoolPanels.forEach((panel, index) => {
                const nameVal = panel.querySelector("input.name").value;
                const nicknameVal = panel.querySelector("input.nickname").value;
                const lockedVal = panel.querySelector("input.locked").checked ? "true" : "false";
                const descriptionVal = panel.querySelector("textarea.description").value;
                const countVal = panel.querySelector("input.count").value;
                const decimalsVal = panel.querySelector("input.decimals").value;
                const maximumVal = panel.querySelector("input.maximum").value;
                const minimumVal = panel.querySelector("input.minimum").value;

                const genePoolObj = genePoolObjects[index];
                const containerChunk = genePoolObj.querySelector('chunk[name="Container"]');
                if (containerChunk) {
                    updateLockedItem(containerChunk, lockedVal);
                    const nameItem = containerChunk.querySelector('item[name="Name"]');
                    const nicknameItem = containerChunk.querySelector('item[name="NickName"]');
                    const descriptionItem = containerChunk.querySelector('item[name="Description"]');
                    if (nameItem) nameItem.textContent = nameVal;
                    if (nicknameItem) nicknameItem.textContent = nicknameVal;
                    if (descriptionItem) descriptionItem.textContent = descriptionVal;
                }

                const geneDataChunk = containerChunk.querySelector('chunk[name="GeneData"]');
                if (geneDataChunk) {
                    const countItem = geneDataChunk.querySelector('item[name="Count"]');
                    const decimalsItem = geneDataChunk.querySelector('item[name="Decimals"]');
                    const maximumItem = geneDataChunk.querySelector('item[name="Maximum"]');
                    const minimumItem = geneDataChunk.querySelector('item[name="Minimum"]');
                    if (countItem) countItem.textContent = countVal;
                    if (decimalsItem) decimalsItem.textContent = decimalsVal;
                    if (maximumItem) maximumItem.textContent = maximumVal;
                    if (minimumItem) minimumItem.textContent = minimumVal;

                    const geneValueInputs = panel.querySelectorAll("input.geneValue");
                    const geneValueItems = geneDataChunk.querySelectorAll('item[name="Value"]');
                    geneValueInputs.forEach((input, i) => {
                        if (geneValueItems[i]) {
                            geneValueItems[i].textContent = input.value;
                        }
                    });
                }
            });
            // End Gene Pools

            // Update Persistent Data
            const pdPanels = persistentDataContainer.querySelectorAll(".persistentDataPanel");
            pdPanels.forEach((panel, index) => {
                const newName = panel.querySelector("input.pdName").value;
                const newNickname = panel.querySelector("input.pdNickname").value;
                const newDescription = panel.querySelector("textarea.pdDescription").value;
                const lockedVal = panel.querySelector("input.locked").checked ? "true" : "false";
                const hiddenVal = panel.querySelector("input.hidden").checked ? "true" : "false"; // Ensure this line is correct

                const containerChunk = persistentDataContainers[index];
                if (containerChunk) {
                    updateLockedItem(containerChunk, lockedVal);
                    updateHiddenItem(containerChunk, hiddenVal); // Ensure this function is defined and works correctly
                    const nameItem = containerChunk.querySelector('item[name="Name"]');
                    const nicknameItem = containerChunk.querySelector('item[name="NickName"]');
                    const descriptionItem = containerChunk.querySelector('item[name="Description"]');
                    if (nameItem) nameItem.textContent = newName;
                    if (nicknameItem) nicknameItem.textContent = newNickname;
                    if (descriptionItem) descriptionItem.textContent = newDescription;
                }

                const items = getPersistentItemsFromContainer(containerChunk);
                const rows = panel.querySelectorAll("table.persistentDataTable tbody tr");
                rows.forEach((row, i) => {
                    if (i < items.length) {
                        const itemNode = items[i];
                        const typeName = itemNode.getAttribute("type_name");
                        let newValue = "";
                        const input = row.querySelector("input.persistentValue");
                        if (typeName === "gh_bool") {
                            newValue = input.checked ? "true" : "false";
                        } else {
                            newValue = input.value;
                        }
                        itemNode.textContent = newValue;
                    }
                });
            });

            // Update Python components.
            const pythonPanels = pythonContainer.querySelectorAll(".pythonPanel");
            pythonPanels.forEach((panel, index) => {
                const newName = panel.querySelector("input.name").value;
                const newNickname = panel.querySelector("input.nickname").value;
                const newDescription = panel.querySelector("textarea.description").value;
                const newCodeInput = panel.querySelector("textarea.codeInput").value;

                const containerChunk = pythonObjects[index].querySelector('chunk[name="Container"]');
                if (containerChunk) {
                    updateLockedItem(
                        containerChunk,
                        panel.querySelector("input.locked").checked ? "true" : "false"
                    );
                    updateHiddenItem(
                        containerChunk,
                        panel.querySelector("input.hidden").checked ? "true" : "false"
                    );
                    const nameItem = containerChunk.querySelector('item[name="Name"]');
                    const nicknameItem = containerChunk.querySelector('item[name="NickName"]');
                    const descriptionItem = containerChunk.querySelector('item[name="Description"]');
                    const codeInputItem = containerChunk.querySelector('item[name="CodeInput"]');
                    if (nameItem) nameItem.textContent = newName;
                    if (nicknameItem) nicknameItem.textContent = newNickname;
                    if (descriptionItem) descriptionItem.textContent = newDescription;
                    if (codeInputItem) codeInputItem.textContent = newCodeInput;
                }
            });

            // Update C# components.
            const csharpPanels = csharpContainer.querySelectorAll(".csharpPanel");
            csharpPanels.forEach((panel, index) => {
                const newName = panel.querySelector("input.name").value;
                const newNickname = panel.querySelector("input.nickname").value;
                const newDescription = panel.querySelector("textarea.description").value;

                // Safely get values from optional textareas
                const additionalSourceTextarea = panel.querySelector("textarea.additionalSource");
                const scriptSourceTextarea = panel.querySelector("textarea.scriptSource");
                const usingSourceTextarea = panel.querySelector("textarea.usingSource");

                const newAdditionalSource = additionalSourceTextarea ? additionalSourceTextarea.value : "";
                const newScriptSource = scriptSourceTextarea ? scriptSourceTextarea.value : "";
                const newUsingSource = usingSourceTextarea ? usingSourceTextarea.value : "";

                // Get references
                const referenceInputs = panel.querySelectorAll("input.reference");
                const references = Array.from(referenceInputs).map((input) => input.value.trim());

                const containerChunk = csharpObjects[index].querySelector('chunk[name="Container"]');
                if (containerChunk) {
                    updateLockedItem(
                        containerChunk,
                        panel.querySelector("input.locked").checked ? "true" : "false"
                    );
                    updateHiddenItem(
                        containerChunk,
                        panel.querySelector("input.hidden").checked ? "true" : "false"
                    );

                    // Update basic properties
                    const nameItem = containerChunk.querySelector('item[name="Name"]');
                    const nicknameItem = containerChunk.querySelector('item[name="NickName"]');
                    const descriptionItem = containerChunk.querySelector('item[name="Description"]');
                    if (nameItem) nameItem.textContent = newName;
                    if (nicknameItem) nicknameItem.textContent = newNickname;
                    if (descriptionItem) descriptionItem.textContent = newDescription;

                    // Update source items if they exist in the XML
                    const additionalSourceItem = containerChunk.querySelector('item[name="AdditionalSource"]');
                    const scriptSourceItem = containerChunk.querySelector('item[name="ScriptSource"]');
                    const usingSourceItem = containerChunk.querySelector('item[name="UsingSource"]');

                    if (additionalSourceItem && additionalSourceTextarea) {
                        additionalSourceItem.textContent = newAdditionalSource;
                    }
                    if (scriptSourceItem && scriptSourceTextarea) {
                        scriptSourceItem.textContent = newScriptSource;
                    }
                    if (usingSourceItem && usingSourceTextarea) {
                        usingSourceItem.textContent = newUsingSource;
                    }

                    // Update references
                    const referenceCountItem = containerChunk.querySelector('item[name="ReferenceCount"]');
                    if (referenceCountItem) {
                        referenceCountItem.textContent = references.length.toString();
                    }

                    // Update existing reference items in place
                    const existingRefs = containerChunk.querySelectorAll('item[name="Reference"]');
                    existingRefs.forEach((ref, idx) => {
                        if (references[idx]) {
                            ref.textContent = references[idx];
                        }
                    });
                }
            });

            // Update General Components (for modifiable fields)
            const generalPanels = generalContainer.querySelectorAll(".generalPanel");
            generalPanels.forEach((panel, index) => {
                const nameVal = panel.querySelector("input.name").value;
                const nicknameVal = panel.querySelector("input.nickname").value;
                const lockedVal = panel.querySelector("input.locked").checked ? "true" : "false";
                const hiddenVal = panel.querySelector("input.hidden").checked ? "true" : "false";
                const descriptionVal = panel.querySelector("textarea.description").value;
                const instanceGuid = panel.dataset.guid;

                // Find the container chunk corresponding to this general component
                let containerChunk = null;
                const containers = xmlDoc.querySelectorAll('chunk[name="Container"]');
                containers.forEach((cc) => {
                    const guid = cc.querySelector('item[name="InstanceGuid"]')?.textContent;
                    if (guid === instanceGuid) {
                        containerChunk = cc;
                    }
                });

                if (containerChunk) {
                    const nameItem = containerChunk.querySelector('item[name="Name"]');
                    const nicknameItem = containerChunk.querySelector('item[name="NickName"]');
                    let lockedItem = containerChunk.querySelector('item[name="Locked"]');
                    let hiddenItem = containerChunk.querySelector('item[name="Hidden"]');
                    const descriptionItem = containerChunk.querySelector('item[name="Description"]');

                    if (nameItem) nameItem.textContent = nameVal;
                    if (nicknameItem) nicknameItem.textContent = nicknameVal;

                    // Update locked item if it exists; otherwise, add one.
                    if (lockedItem) {
                        lockedItem.textContent = lockedVal;
                    } else {
                        updateLockedItem(containerChunk, lockedVal);
                    }
                    if (hiddenItem) {
                        hiddenItem.textContent = hiddenVal;
                    } else {
                        updateHiddenItem(containerChunk, hiddenVal);
                    }
                    if (descriptionItem) descriptionItem.textContent = descriptionVal;
                }
            });

            globalComponents.forEach((component) => {
                updateComponentPosition(component.instanceGuid, component.bounds.x, component.bounds.y);
            });
            // Serialize XML and trigger download
            const serializer = new XMLSerializer();
            const updatedXML = serializer.serializeToString(xmlDoc);
            fileContent.textContent = updatedXML;
            const blob = new Blob([updatedXML], { type: "application/xml" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = fileName.replace(/(\.ghx|\.xml)$/i, "_modified$1");
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            updateFileContent(updatedXML);
        });

        // Function to update component position during drag
        function updateComponentPosition(componentId, newX, newY) {
            const component = globalComponents.find((c) => c.instanceGuid === componentId);
            if (component) {
                // Update bounds (assumed that component.bounds has keys x, y, w, h)
                component.bounds.x = newX;
                component.bounds.y = newY;

                const width = component.bounds.width || component.bounds.w;
                const height = component.bounds.height || component.bounds.h;

                // Use pivotOffset if available. The new center is at newX + width/2, newY + height/2.
                if (component.pivotOffset) {
                    component.pivot.x = newX + width / 2 + component.pivotOffset.x;
                    component.pivot.y = newY + height / 2 + component.pivotOffset.y;
                } else {
                    // Fallback: use geometric center.
                    component.pivot.x = newX + width / 2;
                    component.pivot.y = newY + height / 2;
                }

                // Update XML immediately.
                const container = component.container;
                if (container) {
                    let attributesChunk = container.querySelector('chunk[name="Attributes"]');
                    if (!attributesChunk) {
                        attributesChunk = xmlDoc.createElement("chunk");
                        attributesChunk.setAttribute("name", "Attributes");
                        container.appendChild(attributesChunk);
                    }

                    // Update Bounds in XML.
                    let boundsItem = attributesChunk.querySelector('item[name="Bounds"]');
                    if (!boundsItem) {
                        boundsItem = xmlDoc.createElement("item");
                        boundsItem.setAttribute("name", "Bounds");
                        attributesChunk.appendChild(boundsItem);
                    }
                    updateXMLValue(boundsItem, "X", component.bounds.x);
                    updateXMLValue(boundsItem, "Y", component.bounds.y);
                    updateXMLValue(boundsItem, "W", component.bounds.w);
                    updateXMLValue(boundsItem, "H", component.bounds.h);

                    // Update Pivot in XML.
                    let pivotItem = attributesChunk.querySelector('item[name="Pivot"]');
                    if (!pivotItem) {
                        pivotItem = xmlDoc.createElement("item");
                        pivotItem.setAttribute("name", "Pivot");
                        attributesChunk.appendChild(pivotItem);
                    }
                    updateXMLValue(pivotItem, "X", component.pivot.x);
                    updateXMLValue(pivotItem, "Y", component.pivot.y);
                }
            }
        }

        // Helper function to update XML values.
        function updateXMLValue(parent, nodeName, value) {
            let node = parent.querySelector(nodeName);
            if (!node) {
                node = xmlDoc.createElement(nodeName);
                parent.appendChild(node);
            }
            // Use fixed decimal precision for numbers, if needed.
            node.textContent = typeof value === "number" ? value.toFixed(6) : value.toString();
        }

        let globalComponents = [];

        // ----- DISPLAY COMPONENTS AS SVG -----
        // Placeholder: Calculate bounds, inputs, outputs, and connections.
        function displayComponents(xmlDoc) {
            globalComponents = [];
            const components = [];
            const objects = xmlDoc.querySelectorAll('chunk[name="Object"]');
            objects.forEach((obj) => {
                const guidEl = obj.querySelector('item[name="GUID"]');
                const nameEl = obj.querySelector('item[name="Name"]');
                if (!guidEl || !nameEl) return;
                const compGUID = guidEl.textContent.trim();
                const compName = nameEl.textContent.trim();
                const container = obj.querySelector('chunk[name="Container"]');
                if (!container) return;
                const containerInstanceGuidEl = container.querySelector('item[name="InstanceGuid"]');
                const containerInstanceGuid = containerInstanceGuidEl
                    ? containerInstanceGuidEl.textContent.trim()
                    : "";
                const nickEl = container.querySelector('item[name="NickName"]');
                const compNick = nickEl ? nickEl.textContent.trim() : "";
                const descriptionEl = container.querySelector('item[name="Description"]');
                const description = descriptionEl ? descriptionEl.textContent.trim() : "";

                // --- NEW: Read Locked Value ---
                const lockedEl = container.querySelector('item[name="Locked"]');
                const lockedVal = lockedEl ? lockedEl.textContent.trim() : "false";
                const hiddenEl = container.querySelector('item[name="Hidden"]');
                const hiddenVal = hiddenEl ? hiddenEl.textContent.trim() : "false";

                const persistentDataEl = container.querySelector('chunk[name="PersistentData"]');
                let persistentData = "";
                if (persistentDataEl) {
                    const extracted = extractPersistentData(persistentDataEl);
                    persistentData = extracted.join("\n");
                }
                let valueData = "";
                const valueChunk =
                    container.querySelector('chunk[name="RuntimeData"]') ||
                    container.querySelector('chunk[name="Preview"]') ||
                    container.querySelector('chunk[name="Values"]');
                if (valueChunk) {
                    valueData = Array.from(valueChunk.querySelectorAll("item"))
                        .map((item) => `${item.getAttribute("name")}: ${item.textContent.trim()}`)
                        .join("\n");
                }
                let compBounds = { x: 0, y: 0, w: 50, h: 30 };
                let compPivot = { x: 0, y: 0 };
                const attrChunk = container.querySelector('chunk[name="Attributes"]');
                if (attrChunk) {
                    const boundsEl = attrChunk.querySelector('item[name="Bounds"]');
                    if (boundsEl) {
                        compBounds = {
                            x: parseFloat(boundsEl.querySelector("X")?.textContent.trim() || "0"),
                            y: parseFloat(boundsEl.querySelector("Y")?.textContent.trim() || "0"),
                            w: parseFloat(boundsEl.querySelector("W")?.textContent.trim() || "50"),
                            h: parseFloat(boundsEl.querySelector("H")?.textContent.trim() || "30")
                        };
                    }
                    const pivotEl = attrChunk.querySelector('item[name="Pivot"]');
                    if (pivotEl) {
                        compPivot = {
                            x: parseFloat(
                                pivotEl.querySelector("X")?.textContent.trim() || compBounds.x + compBounds.w / 2
                            ),
                            y: parseFloat(
                                pivotEl.querySelector("Y")?.textContent.trim() || compBounds.y + compBounds.h / 2
                            )
                        };
                    } else {
                        compPivot = { x: compBounds.x + compBounds.w / 2, y: compBounds.y + compBounds.h / 2 };
                    }
                }
                // **Compute the pivot offset:** (difference between saved pivot and geometric center)
                const centerX = compBounds.x + compBounds.w / 2;
                const centerY = compBounds.y + compBounds.h / 2;
                const pivotOffset = {
                    x: compPivot.x - centerX,
                    y: compPivot.y - centerY
                };

                const component = {
                    guid: compGUID,
                    name: compName,
                    nickname: compNick,
                    description: description,
                    locked: lockedVal,
                    hidden: hiddenVal,
                    isPlaceholder: sectionGuids.placeHolders.has(compGUID), // Add this line
                    bounds: compBounds,
                    pivot: compPivot,
                    pivotOffset: pivotOffset,
                    instanceGuid: containerInstanceGuid,
                    inputs: [],
                    outputs: [],
                    container: container
                };

                // Special Handling:
                if (compName === "Panel") {
                    const userTextEl = container.querySelector('item[name="UserText"]');
                    if (userTextEl) {
                        component.userText = userTextEl.textContent.trim();
                    } else {
                        component.userText = persistentData || valueData;
                    }
                }
                if (compName === "Expression") {
                    const exprEl = container.querySelector('item[name="Expression"]');
                    if (exprEl) {
                        component.expression = exprEl.textContent.trim();
                    }
                }
                if (compName === "Value List") {
                    let itemsArr = [];
                    const listItems = container.querySelectorAll('chunk[name="ListItem"]');
                    listItems.forEach((li) => {
                        const nameEl = li.querySelector('item[name="Name"]');
                        const exprEl = li.querySelector('item[name="Expression"]');
                        if (nameEl && exprEl) {
                            itemsArr.push(`${nameEl.textContent.trim()} (${exprEl.textContent.trim()})`);
                        }
                    });
                    if (itemsArr.length) {
                        component.items = itemsArr.join(", ");
                    }
                }
                const sliderChunk = container.querySelector('chunk[name="Slider"]');
                if (sliderChunk) {
                    const sliderItems = Array.from(sliderChunk.querySelectorAll("item"))
                        .map((item) => `${item.getAttribute("name")}: ${parseValue(item.textContent.trim())}`)
                        .join("\n");
                    component.slider = sliderItems;
                }
                if (compName === "GhPython Script") {
                    const codeInputEl = container.querySelector('item[name="CodeInput"]');
                    if (codeInputEl) {
                        component.codeInput = codeInputEl.textContent.trim();
                    }
                }
                if (compName === "C# Script") {
                    const addSrcEl = container.querySelector('item[name="AdditionalSource"]');
                    const scriptSrcEl = container.querySelector('item[name="ScriptSource"]');
                    const usingSrcEl = container.querySelector('item[name="UsingSource"]');
                    if (addSrcEl) {
                        component.additionalSource = addSrcEl.textContent.trim();
                    }
                    if (scriptSrcEl) {
                        component.scriptSource = scriptSrcEl.textContent.trim();
                    }
                    if (usingSrcEl) {
                        component.usingSource = usingSrcEl.textContent.trim();
                    }
                }
                let inputChunks = null,
                    outputChunks = null;
                const parameterData = container.querySelector('chunk[name="ParameterData"]');
                if (parameterData) {
                    inputChunks = parameterData.querySelectorAll(
                        'chunk[name^="InputParam"], chunk[name^="param_input"]'
                    );
                    outputChunks = parameterData.querySelectorAll(
                        'chunk[name^="OutputParam"], chunk[name^="param_output"]'
                    );
                } else {
                    const allChunks = container.querySelectorAll("chunk");
                    inputChunks = Array.from(allChunks).filter((c) => {
                        const nameAttr = c.getAttribute("name");
                        return (
                            nameAttr && (nameAttr.startsWith("InputParam") || nameAttr.startsWith("param_input"))
                        );
                    });
                    outputChunks = Array.from(allChunks).filter((c) => {
                        const nameAttr = c.getAttribute("name");
                        return (
                            nameAttr && (nameAttr.startsWith("OutputParam") || nameAttr.startsWith("param_output"))
                        );
                    });
                }
                inputChunks.forEach((paramChunk) => {
                    const pNameEl = paramChunk.querySelector('item[name="Name"]');
                    const pNickEl = paramChunk.querySelector('item[name="NickName"]');
                    const pName = pNameEl ? pNameEl.textContent.trim() : "Input";
                    const pNick = pNickEl ? pNickEl.textContent.trim() : "";
                    const pInstanceGuid = paramChunk.querySelector('item[name="InstanceGuid"]')
                        ? paramChunk.querySelector('item[name="InstanceGuid"]').textContent.trim()
                        : component.guid + "-inp";

                    // Add this line to capture WireDisplay property
                    const wireDisplayEl = paramChunk.querySelector('item[name="WireDisplay"]');
                    const wireDisplay = wireDisplayEl ? parseInt(wireDisplayEl.textContent.trim()) : 1;

                    let pBounds = { x: 0, y: 0, w: 0, h: 0 };
                    let pPivot = { x: 0, y: 0 };
                    const pAttr = paramChunk.querySelector('chunk[name="Attributes"]');
                    if (pAttr) {
                        const pb = pAttr.querySelector('item[name="Bounds"]');
                        if (pb) {
                            pBounds = {
                                x: parseFloat(pb.querySelector("X")?.textContent.trim() || "0"),
                                y: parseFloat(pb.querySelector("Y")?.textContent.trim() || "0"),
                                w: parseFloat(pb.querySelector("W")?.textContent.trim() || "0"),
                                h: parseFloat(pb.querySelector("H")?.textContent.trim() || "0")
                            };
                        }
                        const pp = pAttr.querySelector('item[name="Pivot"]');
                        if (pp) {
                            pPivot = {
                                x: parseFloat(pp.querySelector("X")?.textContent.trim() || "0"),
                                y: parseFloat(pp.querySelector("Y")?.textContent.trim() || "0")
                            };
                        }
                    }
                    let inputPersistentData = "";
                    const inputPD = paramChunk.querySelector('chunk[name="PersistentData"]');
                    if (inputPD) {
                        const filteredInputData = Array.from(inputPD.children)
                            .map((child) => {
                                const key = child.getAttribute("name");
                                const rawVal = child.textContent.trim();
                                const parsedVal = parseValue(rawVal);
                                if (
                                    parsedVal !== null &&
                                    (typeof parsedVal === "string" ||
                                        typeof parsedVal === "number" ||
                                        typeof parsedVal === "boolean")
                                ) {
                                    return `${key}: ${parsedVal}`;
                                }
                                return null;
                            })
                            .filter((item) => item !== null);
                        inputPersistentData = filteredInputData.join("\n");
                    }
                    component.inputs.push({
                        name: pName,
                        nickname: pNick,
                        instanceGuid: pInstanceGuid,
                        bounds: pBounds,
                        pivot: pPivot,
                        sources: Array.from(paramChunk.querySelectorAll('item[name="Source"]')).map((src) =>
                            src.textContent.trim()
                        ),
                        wireDisplay: wireDisplay, // Add this line
                        persistentData: inputPersistentData
                    });
                });
                outputChunks.forEach((paramChunk) => {
                    const pNameEl = paramChunk.querySelector('item[name="Name"]');
                    const pNickEl = paramChunk.querySelector('item[name="NickName"]');
                    const pName = pNameEl ? pNameEl.textContent.trim() : "Output";
                    const pNick = pNickEl ? pNickEl.textContent.trim() : "";
                    const pInstanceGuid = paramChunk.querySelector('item[name="InstanceGuid"]')
                        ? paramChunk.querySelector('item[name="InstanceGuid"]').textContent.trim()
                        : component.guid + "-out";
                    let pBounds = { x: 0, y: 0, w: 0, h: 0 };
                    let pPivot = { x: 0, y: 0 };
                    const pAttr = paramChunk.querySelector('chunk[name="Attributes"]');
                    if (pAttr) {
                        const pb = pAttr.querySelector('item[name="Bounds"]');
                        if (pb) {
                            pBounds = {
                                x: parseFloat(pb.querySelector("X")?.textContent.trim() || "0"),
                                y: parseFloat(pb.querySelector("Y")?.textContent.trim() || "0"),
                                w: parseFloat(pb.querySelector("W")?.textContent.trim() || "0"),
                                h: parseFloat(pb.querySelector("H")?.textContent.trim() || "0")
                            };
                        }
                        const pp = pAttr.querySelector('item[name="Pivot"]');
                        if (pp) {
                            pPivot = {
                                x: parseFloat(pp.querySelector("X")?.textContent.trim() || "0"),
                                y: parseFloat(pp.querySelector("Y")?.textContent.trim() || "0")
                            };
                        }
                    }
                    component.outputs.push({
                        name: pName,
                        nickname: pNick,
                        instanceGuid: pInstanceGuid,
                        bounds: pBounds,
                        pivot: pPivot,
                        sources: []
                    });
                });
                if (component.inputs.length === 0) {
                    component.inputs.push({
                        name: "Default Input",
                        nickname: "",
                        instanceGuid: component.instanceGuid + "-default-inp",
                        bounds: { x: compBounds.x, y: compBounds.y, w: 0, h: 0 },
                        pivot: { x: compBounds.x, y: compBounds.y + compBounds.h / 2 },
                        sources: []
                    });
                }
                if (component.outputs.length === 0) {
                    component.outputs.push({
                        name: "Default Output",
                        nickname: "",
                        instanceGuid: component.instanceGuid,
                        bounds: { x: compBounds.x, y: compBounds.y, w: 0, h: 0 },
                        pivot: { x: compBounds.x + compBounds.w, y: compBounds.y + compBounds.h / 2 },
                        sources: []
                    });
                }
                Array.from(container.querySelectorAll('item[name="Source"]')).forEach((srcNode) => {
                    const srcGuid = srcNode.textContent.trim();
                    if (!component.inputs.some((inp) => inp.sources.includes(srcGuid))) {
                        component.inputs[0].sources.push(srcGuid);
                    }
                });
                components.push(component);
            });

            const connections = [];
            components.forEach((comp) => {
                comp.inputs.forEach((inputParam, inputIndex) => {
                    inputParam.sources.forEach((srcGuid) => {
                        components.forEach((otherComp) => {
                            otherComp.outputs.forEach((outputParam, outputIndex) => {
                                if (outputParam.instanceGuid === srcGuid) {
                                    connections.push({
                                        fromComponent: otherComp.name,
                                        fromOutputIndex: outputIndex,
                                        fromOutputInstanceGuid: outputParam.instanceGuid,
                                        toComponent: comp.name,
                                        toInputIndex: inputIndex,
                                        toInputInstanceGuid: inputParam.instanceGuid,
                                        sourceGuid: srcGuid
                                    });
                                }
                            });
                        });
                    });
                });
            });

            globalComponents = components;
            drawSVG(components, connections);
        }

        // Example flag; you can update this based on your app logic.
        let unsavedChanges = true; // Set to true if there are unsaved changes
        function showSavePopup() {
            const modal = document.getElementById("savePopup");
            // Set display so it's in the layout
            modal.style.display = "block";
            // Allow a reflow before adding the class to trigger transition
            setTimeout(() => {
                modal.classList.add("show");
            }, 10);
        }

        function hideSavePopup() {
            const modal = document.getElementById("savePopup");
            modal.classList.remove("show");
            // Wait for the transition to complete before setting display to none
            setTimeout(() => {
                modal.style.display = "none";
            }, 500); // This delay should match your CSS transition duration
        }

        document.getElementById("openBtn").addEventListener("click", function () {
            // Only prompt if a file is already loaded
            if (xmlDoc) {
                showSavePopup();
            } else {
                document.getElementById("fileInput").click();
            }
        });

        document.getElementById("saveYesBtn").addEventListener("click", function () {
            document.getElementById("saveBtn").click(); // Save the file
            unsavedChanges = false; // Reset flag, for example
            hideSavePopup();
            document.getElementById("fileInput").click();
        });

        document.getElementById("saveNoBtn").addEventListener("click", function () {
            unsavedChanges = false;
            hideSavePopup();
            document.getElementById("fileInput").click();
        });

        // ----- FILE INPUT & COMPONENT DISPLAY -----
        document.getElementById("fileInput").addEventListener("change", function (e) {
            const file = e.target.files[0];
            if (!file) return;

            // Store the full file path and extension
            currentFilePath = file.path || file.webkitRelativePath || file.name;
            fileName = file.name;
            originalFileExtension = fileName.split('.').pop().toLowerCase(); // Store original extension

            // Update the filename display
            const filenameDisplay = document.getElementById("filenameDisplay");
            if (currentFilePath && currentFilePath.trim() !== "") {
                filenameDisplay.textContent = currentFilePath;
                filenameDisplay.style.display = "block"; // Show the element
            } else {
                filenameDisplay.style.display = "none"; // Hide it if no path
            }

            const reader = new FileReader();
            reader.onload = function (evt) {
                originalXmlText = evt.target.result;
                fileContent.textContent = originalXmlText;
                const parser = new DOMParser();
                xmlDoc = parser.parseFromString(originalXmlText, "application/xml");
                
                // Populate placeholders first
                populatePlaceholderList();
                
                // Then display components (now it can use the populated placeHolders set)
                displayComponents(xmlDoc);
                
                // Populate other sections
                populateSlidersList();
                populateTogglesList();
                populatePanelsList();
                populateExpressionsList();
                populateValueListsList();
                populatePersistentDataList();
                populatePythonComponentList();
                populateCSharpComponentList();
                populateColorSwatchList();
                populateScribblesList();
                populateSketchesList();
                populateGenePoolList();
                populateGeneralComponentsList();
                
                // Attach collapse behavior to the section headers
                //attachSectionCollapse();
                updateSectionCounts();
                attachLockedListeners();
                attachHiddenListeners();
            };
            reader.readAsText(file);
        });

        // ----- Status Display Function -----
        function showStatus(message, type) {
            let statusDiv = document.getElementById("status");
            if (!statusDiv) {
                statusDiv = document.createElement("div");
                statusDiv.id = "status";
                document.body.appendChild(statusDiv);
            }
            statusDiv.textContent = message;
            statusDiv.className = type;
            statusDiv.style.display = "block";
        }

        // Attach section collapse to section headers in side-panel.
        attachSectionCollapse();

        //---------------------------------------------
        // Zoom
        //---------------------------------------------

        // ----- SVG ZOOM HANDLER -----
        class SVGZoomHandler {
            constructor(svg) {
                this.svg = svg;
                this.zoomStart = null;
                this.zoomRectElement = null;
            }

            getSVGPoint(clientX, clientY) {
                const pt = this.svg.createSVGPoint();
                pt.x = clientX;
                pt.y = clientY;
                return pt.matrixTransform(this.svg.getScreenCTM().inverse());
            }

            getCurrentTransform() {
                return panZoomGroup.transform.baseVal.consolidate()?.matrix || this.svg.createSVGMatrix();
            }

            onWheel(e) {
                e.preventDefault();
                const mouse = this.getSVGPoint(e.clientX, e.clientY);
                const factor = Math.pow(1.1, -Math.sign(e.deltaY));

                const transform = this.getCurrentTransform();
                const newScale = transform.a * factor;

                transform.a = transform.d = newScale;
                transform.e += (1 - factor) * (mouse.x - transform.e);
                transform.f += (1 - factor) * (mouse.y - transform.f);

                const newTransform = this.svg.createSVGTransform();
                newTransform.setMatrix(transform);
                panZoomGroup.transform.baseVal.clear();
                panZoomGroup.transform.baseVal.appendItem(newTransform);
            }

            createZoomRect() {
                const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                rect.setAttribute("fill", "rgba(0, 100, 255, 0.15)");
                rect.setAttribute("stroke", "#0066cc");
                rect.setAttribute("vector-effect", "non-scaling-stroke");
                rect.setAttribute("stroke-width", "1");
                rect.setAttribute("stroke-dasharray", "3,3");
                rect.style.pointerEvents = "none";
                return rect;
            }

            onRightClickZoom(e) {
                if (e.button !== 2) return;
                e.preventDefault();
                const p = this.getSVGPoint(e.clientX, e.clientY);
                this.zoomStart = p;
                this.zoomRectElement = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                this.zoomRectElement.setAttribute("fill", "rgba(0,0,255,0.2)");
                this.zoomRectElement.setAttribute("stroke", "darkblue");
                this.zoomRectElement.setAttribute("stroke-width", "0.6");
                this.svg.appendChild(this.zoomRectElement);

                const onZoomMouseMove = (e) => {
                    if (!this.zoomStart) return;
                    const p2 = this.getSVGPoint(e.clientX, e.clientY);
                    const x = Math.min(this.zoomStart.x, p2.x);
                    const y = Math.min(this.zoomStart.y, p2.y);
                    const width = Math.abs(p2.x - this.zoomStart.x);
                    const height = Math.abs(p2.y - this.zoomStart.y);
                    this.zoomRectElement.setAttribute("x", x);
                    this.zoomRectElement.setAttribute("y", y);
                    this.zoomRectElement.setAttribute("width", width);
                    this.zoomRectElement.setAttribute("height", height);
                };

                const onZoomMouseUp = (e) => {
                    if (!this.zoomStart) return;
                    const p2 = this.getSVGPoint(e.clientX, e.clientY);
                    const x = Math.min(this.zoomStart.x, p2.x);
                    const y = Math.min(this.zoomStart.y, p2.y);
                    const width = Math.abs(p2.x - this.zoomStart.x);
                    const height = Math.abs(p2.y - this.zoomStart.y);
                    if (width > 10 && height > 10) {
                        this.svg.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
                    }
                    this.zoomStart = null;
                    if (this.zoomRectElement) {
                        this.svg.removeChild(this.zoomRectElement);
                        this.zoomRectElement = null;
                    }
                    this.svg.removeEventListener("mousemove", onZoomMouseMove);
                    this.svg.removeEventListener("mouseup", onZoomMouseUp);
                };

                this.svg.addEventListener("mousemove", onZoomMouseMove);
                this.svg.addEventListener("mouseup", onZoomMouseUp);
            }
        }

        function startDrag(evt, component) {
            if (evt.button !== 0) return; // Only left click
            const point = zoomHandler.getSVGPoint(evt.clientX, evt.clientY);

            if (isPointInComponentBounds(point, component)) {
                evt.stopPropagation();
                isDragging = true;
                currentComponent = component;

                // Highlight only the bounds of the component
                const boundingRect = document.querySelector(`[data-guid="${component.instanceGuid}"] rect`); // Select the bounding rectangle
                if (boundingRect) {
                    boundingRect.classList.add("highlight"); // Add highlight class to the rectangle
                }

                const transform = zoomHandler.getCurrentTransform();
                offset.x = point.x - (component.bounds.x * transform.a + transform.e);
                offset.y = point.y - (component.bounds.y * transform.d + transform.f);
            }
        }

        function endDrag() {
            // Store the current component before setting it to null
            const componentToHighlight = currentComponent;
            isDragging = false;
            currentComponent = null;

            // Remove highlight from the bounding rectangle
            if (componentToHighlight) {
                const boundingRect = document.querySelector(
                    `[data-guid="${componentToHighlight.instanceGuid}"] rect`
                ); // Select the bounding rectangle
                if (boundingRect) {
                    boundingRect.classList.remove("highlight"); // Remove highlight class from the rectangle
                }
            }
        }

        function drag(evt) {
            if (!isDragging || !currentComponent) return;
            evt.preventDefault();

            const point = zoomHandler.getSVGPoint(evt.clientX, evt.clientY);
            const transform = zoomHandler.getCurrentTransform();

            // Calculate new position accounting for zoom scale
            const newX = (point.x - offset.x - transform.e) / transform.a;
            const newY = (point.y - offset.y - transform.f) / transform.d;

            // Calculate the change in position
            const dx = newX - currentComponent.bounds.x;
            const dy = newY - currentComponent.bounds.y;

            // Update component position
            currentComponent.bounds.x = newX;
            currentComponent.bounds.y = newY;

            currentComponent.pivot.x = newX;
            currentComponent.pivot.y = newY;

            // Update inputs and outputs with the same displacement
            currentComponent.inputs.forEach((input) => {
                input.bounds.x += dx;
                input.bounds.y += dy;
                if (!isNaN(input.pivot.x) && !isNaN(input.pivot.y)) {
                    input.pivot.x += dx;
                    input.pivot.y += dy;
                }
            });

            currentComponent.outputs.forEach((output) => {
                output.bounds.x += dx;
                output.bounds.y += dy;
                if (!isNaN(output.pivot.x) && !isNaN(output.pivot.y)) {
                    output.pivot.x += dx;
                    output.pivot.y += dy;
                }
            });

            // Directly update the SVG element's position
            const svgGroup = svgElement.querySelector(`g[data-guid="${currentComponent.instanceGuid}"]`);
            if (svgGroup) {
                const rect = svgGroup.querySelector("rect:not([stroke-dasharray])");
                if (rect) {
                    rect.setAttribute("x", currentComponent.bounds.x);
                    rect.setAttribute("y", currentComponent.bounds.y);
                }

                // Update dashed rectangle if it exists (for hidden components)
                const dashedRect = svgGroup.querySelector('rect[stroke-dasharray="2,2"]');
                if (dashedRect) {
                    const inflation = 3;
                    dashedRect.setAttribute("x", currentComponent.bounds.x - inflation);
                    dashedRect.setAttribute("y", currentComponent.bounds.y - inflation);
                }
                const text = svgGroup.querySelector("text");
                if (text) {
                    text.setAttribute("x", currentComponent.bounds.x + currentComponent.bounds.w / 2);
                    text.setAttribute("y", currentComponent.bounds.y + currentComponent.bounds.h / 2);
                }
                // Update input/output ports positions
                currentComponent.inputs.forEach((input, index) => {
                    const circle = svgGroup.querySelectorAll("circle")[index];
                    if (circle) {
                        circle.setAttribute("cx", currentComponent.bounds.x);
                        circle.setAttribute("cy", input.pivot.y);
                    }
                });
                currentComponent.outputs.forEach((output, index) => {
                    const circle = svgGroup.querySelectorAll("circle")[currentComponent.inputs.length + index];
                    if (circle) {
                        circle.setAttribute("cx", currentComponent.bounds.x + currentComponent.bounds.w);
                        circle.setAttribute("cy", output.pivot.y);
                    }
                });

                // Update connections related to this component
                connectionsData.forEach((conn) => {
                    const isSource = currentComponent.outputs.some(
                        (out) => out.instanceGuid === conn.fromOutputInstanceGuid
                    );
                    const isTarget = currentComponent.inputs.some(
                        (inp) => inp.instanceGuid === conn.toInputInstanceGuid
                    );

                    if (isSource || isTarget) {
                        let fromPos = null,
                            toPos = null;

                        // Find the positions for the connection
                        componentsData.forEach((comp) => {
                            comp.outputs.forEach((param) => {
                                if (param.instanceGuid === conn.fromOutputInstanceGuid) {
                                    fromPos = {
                                        x: comp.bounds.x + comp.bounds.w,
                                        y: getParamPosition(param, "output").y
                                    };
                                }
                            });
                            comp.inputs.forEach((param) => {
                                if (param.instanceGuid === conn.toInputInstanceGuid) {
                                    toPos = {
                                        x: comp.bounds.x,
                                        y: getParamPosition(param, "input").y
                                    };
                                }
                            });
                        });

                        // Update the connection path
                        if (fromPos && toPos) {
                            const connectionPath = document.querySelector(
                                `path[data-from="${conn.fromOutputInstanceGuid}"][data-to="${conn.toInputInstanceGuid}"]`
                            );
                            if (connectionPath) {
                                const dx = toPos.x - fromPos.x;
                                const dy = toPos.y - fromPos.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                const cp1x = fromPos.x + Math.min(distance * 0.4, 100);
                                const cp2x = toPos.x - Math.min(distance * 0.4, 100);
                                const d = `M ${fromPos.x} ${fromPos.y} C ${cp1x} ${fromPos.y}, ${cp2x} ${toPos.y}, ${toPos.x} ${toPos.y}`;
                                connectionPath.setAttribute("d", d);
                            }
                        }
                    }
                });
            }

            // Update text position
            const text = svgGroup.querySelector(".component-name");
            const icon = svgGroup.querySelector(".component-icon");
            if (text) {
                text.setAttribute("x", currentComponent.bounds.x + currentComponent.bounds.w / 2);
                // If there's an icon, keep text above, otherwise keep it centered
                if (icon) {
                    text.setAttribute("y", currentComponent.bounds.y - 5);
                    // Update icon position
                    icon.setAttribute("x", currentComponent.bounds.x + (currentComponent.bounds.w - ICON_SIZE) / 2);
                    icon.setAttribute("y", currentComponent.bounds.y + (currentComponent.bounds.h - ICON_SIZE) / 2);
                } else {
                    text.setAttribute("y", currentComponent.bounds.y + currentComponent.bounds.h / 2);
                }
            }
        }

        function onCanvasMouseDown(e) {
            if (e.button === 2) {
                // Middle mouse button
                e.preventDefault();
                const startPoint = zoomHandler.getSVGPoint(e.clientX, e.clientY);
                const initialTransform = zoomHandler.getCurrentTransform();
                const startScale = Math.sqrt(
                    initialTransform.a * initialTransform.a + initialTransform.b * initialTransform.b
                );

                const onMouseMove = (e) => {
                    const currentPoint = zoomHandler.getSVGPoint(e.clientX, e.clientY);
                    const dx = currentPoint.x - startPoint.x;
                    const dy = currentPoint.y - startPoint.y;

                    const matrix = initialTransform.translate(dx / startScale, dy / startScale);
                    const newTransform = svgElement.createSVGTransform();
                    newTransform.setMatrix(matrix);

                    panZoomGroup.transform.baseVal.clear();
                    panZoomGroup.transform.baseVal.appendItem(newTransform);
                };

                const onMouseUp = () => {
                    svgElement.removeEventListener("mousemove", onMouseMove);
                    svgElement.removeEventListener("mouseup", onMouseUp);
                    svgElement.removeEventListener("mouseleave", onMouseUp);
                };

                svgElement.addEventListener("mousemove", onMouseMove);
                svgElement.addEventListener("mouseup", onMouseUp);
                svgElement.addEventListener("mouseleave", onMouseUp);
            }
        }

        function isPointInComponentBounds(point, component) {
            const transform = zoomHandler.getCurrentTransform();

            // Convert mouse point to local coordinates
            const localX = (point.x - transform.e) / transform.a;
            const localY = (point.y - transform.f) / transform.d;

            // Get component bounds in local coordinates
            const bounds = component.bounds;

            return (
                localX >= bounds.x &&
                localX <= bounds.x + bounds.w &&
                localY >= bounds.y &&
                localY <= bounds.y + bounds.h
            );
        }

        function handleComponentDoubleClick(component) {
            if (!component.instanceGuid) return;
            let targetSection = null;
            let sectionId = "";

            // Find which section contains this GUID
            if (sectionGuids.placeHolders.has(component.instanceGuid)) {  // Add this check
                sectionId = "#placeholderContainer";
            } else if (sectionGuids.sliders.has(component.instanceGuid)) {
                sectionId = "#slidersContainer";
            } else if (sectionGuids.toggles.has(component.instanceGuid)) {
                sectionId = "#togglesContainer";
            } else if (sectionGuids.panels.has(component.instanceGuid)) {
                sectionId = "#panelsContainer";
            } else if (sectionGuids.expressions.has(component.instanceGuid)) {
                sectionId = "#expressionsContainer";
            } else if (sectionGuids.valueLists.has(component.instanceGuid)) {
                sectionId = "#valueListsContainer";
            } else if (sectionGuids.persistentData.has(component.instanceGuid)) {
                sectionId = "#persistentDataContainer";
            } else if (sectionGuids.python.has(component.instanceGuid)) {
                sectionId = "#pythonContainer";
            } else if (sectionGuids.csharp.has(component.instanceGuid)) {
                sectionId = "#csharpContainer";
            } else if (sectionGuids.colorSwatches.has(component.instanceGuid)) {
                sectionId = "#colorSwatchContainer";
            } else if (sectionGuids.general.has(component.instanceGuid)) {
                sectionId = "#generalContainer";
            } else if (sectionGuids.scribbles.has(component.instanceGuid)) {
                sectionId = "#scribblesContainer";
            } else if (sectionGuids.sketches.has(component.instanceGuid)) {
                sectionId = "#sketchesContainer";
            } else if (sectionGuids.genePools.has(component.instanceGuid)) {
                sectionId = "#genePoolContainer";
            }

            if (sectionId) {
                targetSection = document.querySelector(sectionId).closest(".sectionPanel");
                collapseAllSectionsExcept(targetSection);
                const container = document.querySelector(sectionId);
                const componentPanels = container.querySelectorAll(".componentPanel");

                componentPanels.forEach((panel) => {
                    const content = panel.querySelector(".collapsibleContent");
                    if (panel.dataset.guid === component.instanceGuid) {
                        content.style.display = "block";

                        // Zoom to component after a short delay
                        setTimeout(() => {
                            zoomToComponent(component);
                        }, 100);

                        // Highlight logic
                        const boundingRect = document.querySelector(`[data-guid="${component.instanceGuid}"] rect`);
                        if (boundingRect) {
                            boundingRect.classList.add("highlight-orange");
                            setTimeout(() => {
                                boundingRect.classList.remove("highlight-orange");
                            }, 1500);
                        }

                        panel.scrollIntoView({ behavior: "smooth", block: "start" });
                    } else {
                        content.style.display = "none";
                    }
                });
            }
        }

        // ------------------------------------------------------------------------------------
        // SVG PART (remains unchanged)
        // --- Utility Functions ---

        function getParamPosition(param, type) {
            const bx = parseFloat(param.bounds.x);
            const by = parseFloat(param.bounds.y);
            const bw = parseFloat(param.bounds.w);
            const bh = parseFloat(param.bounds.h);
            const px = parseFloat(param.pivot.x);
            const py = parseFloat(param.pivot.y);
            let x, y;
            if (!isNaN(px) && !isNaN(py)) {
                x = px;
                y = py;
            } else {
                x = type === "input" ? bx : bx + bw;
                y = by + bh / 2;
            }
            return { x, y };
        }

        /*
// Main drawing functions
function drawSVGWithoutZoomReset(components, connections) {
  // Store current viewBox
  const currentViewBox = svgElement.getAttribute("viewBox");

  // Store current transform
  const currentTransform = panZoomGroup?.transform.baseVal.consolidate()?.matrix;

  // Draw SVG
  drawSVG(components, connections);

  // Restore original viewBox
  svgElement.setAttribute("viewBox", currentViewBox);

  // Restore transform
  if (currentTransform) {
    const newTransform = svgElement.createSVGTransform();
    newTransform.setMatrix(currentTransform);
    panZoomGroup.transform.baseVal.clear();
    panZoomGroup.transform.baseVal.appendItem(newTransform);
  }
}
  */

        function renderSketch(container, parentElement) {
            const svgNS = "http://www.w3.org/2000/svg";

            // Get sketch properties
            const sketchProps = container.querySelector('chunk[name="Attributes"] chunk[name="SketchProperties"]');

            // Parse color
            const colorElement = sketchProps?.querySelector('item[name="Color"]');
            let strokeColor = "#000000";
            if (colorElement) {
                const colorText = colorElement.textContent;
                if (colorText.includes(";")) {
                    const [a, r, g, b] = colorText.split(";").map(Number);
                    strokeColor = `rgb(${r},${g},${b})`;
                } else {
                    strokeColor = colorText;
                }
            }

            // Get line width
            const width = parseFloat(sketchProps?.querySelector('item[name="Width"]')?.textContent || "1");

            // Get pattern type
            const pattern = sketchProps?.querySelector('item[name="Pattern"]')?.textContent || "0";

            // Get all Mark chunks for vertices
            const markChunks = container.querySelectorAll('chunk[name="Mark"]');

            // Create a group to hold all polylines
            const group = document.createElementNS(svgNS, "g");

            markChunks.forEach((markChunk, index) => {
                // Create polyline for each mark
                const polyline = document.createElementNS(svgNS, "polyline");

                // Collect all vertices
                const vertices = markChunk.querySelectorAll('item[name="V"]');
                const points = Array.from(vertices)
                    .map((vertex) => {
                        const x = vertex.querySelector("X")?.textContent;
                        const y = vertex.querySelector("Y")?.textContent;
                        return `${x},${y}`;
                    })
                    .join(" ");

                // Set polyline attributes
                polyline.setAttribute("points", points);
                polyline.setAttribute("stroke", strokeColor);
                polyline.setAttribute("stroke-width", width);
                polyline.setAttribute("fill", "none");
                polyline.setAttribute("stroke-linecap", "round");
                polyline.setAttribute("stroke-linejoin", "round");

                // Add data attribute for identification
                polyline.setAttribute("data-line-index", index);

                // Add hover effect styles
                polyline.style.cursor = "pointer";
                polyline.style.transition = "stroke-width 0.2s ease";

                // Apply line pattern if specified
                if (pattern === "1") {
                    polyline.setAttribute("stroke-dasharray", "3,3");
                } else if (pattern === "2") {
                    polyline.setAttribute("stroke-dasharray", "1,1");
                }

                // Add click event listener
                polyline.addEventListener("click", (event) => {
                    handleLineClick(event, index);
                });

                // Add hover events
                polyline.addEventListener("mouseenter", () => {
                    polyline.style.strokeWidth = width * 2 + "px";
                });

                polyline.addEventListener("mouseleave", () => {
                    polyline.style.strokeWidth = width + "px";
                });

                // Add to group
                group.appendChild(polyline);
            });

            // Add the group to parent element
            parentElement.appendChild(group);

            // Function to handle line clicks
            function handleLineClick(event, lineIndex) {
                const clickedLine = event.target;

                // Create a custom event with line data
                const clickEvent = new CustomEvent("sketchLineClick", {
                    detail: {
                        lineIndex: lineIndex,
                        element: clickedLine,
                        points: clickedLine.getAttribute("points"),
                        color: clickedLine.getAttribute("stroke")
                    },
                    bubbles: true
                });

                // Dispatch the event
                //parentElement.dispatchEvent(clickEvent);
            }
        }

        function renderScribble(comp, parentElement) {
            const svgNS = "http://www.w3.org/2000/svg";
            const text = document.createElementNS(svgNS, "text");
            const container = comp.container;

            // Get text properties
            const textContent = container.querySelector('item[name="Text"]')?.textContent || "";
            const fontFamily = container.querySelector('item[name="Font"]')?.textContent || "Arial";
            const fontSize = container.querySelector('item[name="Size"]')?.textContent || "12";
            const isBold = container.querySelector('item[name="Bold"]')?.textContent === "true";
            const isItalic = container.querySelector('item[name="Italic"]')?.textContent === "true";

            // Set text attributes
            text.setAttribute("x", comp.bounds.x);
            text.setAttribute("y", comp.bounds.y);
            text.setAttribute("font-family", fontFamily);
            text.setAttribute("font-size", fontSize);
            text.setAttribute("fill", "#141414");
            if (isBold) text.setAttribute("font-weight", "bold");
            if (isItalic) text.setAttribute("font-style", "italic");
            text.textContent = textContent;

            // Add interactive properties
            text.style.cursor = "pointer";

            // Add data attributes
            text.setAttribute("data-type", "scribble");
            text.setAttribute("data-content", textContent);

            // Add click handler
            text.addEventListener("click", (event) => {
                handleTextClick(event, {
                    type: "scribble",
                    content: textContent,
                    fontFamily,
                    fontSize,
                    isBold,
                    isItalic
                });
            });

            // Add hover effects
            text.addEventListener("mouseenter", () => {
                text.style.filter = "brightness(0.8)";
                text.setAttribute("font-size", `${parseInt(fontSize) * 1.1}`);
            });

            text.addEventListener("mouseleave", () => {
                text.style.filter = "none";
                text.setAttribute("font-size", fontSize);
            });

            parentElement.appendChild(text);
        }

        function handleTextClick(event, textData) {
            // Create custom event for text clicks
            const clickEvent = new CustomEvent("scribbleClick", {
                detail: {
                    type: textData.type,
                    content: textData.content,
                    fontFamily: textData.fontFamily,
                    fontSize: textData.fontSize,
                    isBold: textData.isBold,
                    isItalic: textData.isItalic,
                    bounds: textData.bounds,
                    element: event.target
                },
                bubbles: true
            });

            // Dispatch the event
            event.target.dispatchEvent(clickEvent);
        }

        function drawSVG(components, connections) {
            const visibleComponents = components.filter((comp) => !isGroup(comp));
            componentsData = visibleComponents;
            connectionsData = connections;
            const svgNS = "http://www.w3.org/2000/svg";

            // Calculate bounds (including ports) from your component data.
            let xs = [],
                ys = [];
            visibleComponents.forEach((comp) => {
                xs.push(comp.bounds.x, comp.bounds.x + comp.bounds.w);
                ys.push(comp.bounds.y, comp.bounds.y + comp.bounds.h);
                comp.inputs.forEach((param) => {
                    const pos = getParamPosition(param, "input");
                    xs.push(comp.bounds.x);
                    ys.push(pos.y);
                });
                comp.outputs.forEach((param) => {
                    const pos = getParamPosition(param, "output");
                    xs.push(comp.bounds.x + comp.bounds.w);
                    ys.push(pos.y);
                });
            });
            const padding = 10;
            const minX = Math.min(...xs) - padding;
            const minY = Math.min(...ys) - padding;
            const maxX = Math.max(...xs) + padding;
            const maxY = Math.max(...ys) + padding;
            const contentWidth = maxX - minX;
            const contentHeight = maxY - minY;

            // Get the container dimensions
            const container = document.getElementById("svgViewer");
            const containerRect = container.getBoundingClientRect();
            const containerAspectRatio = containerRect.width / containerRect.height;

            // Calculate content aspect ratio
            const contentAspectRatio = contentWidth / contentHeight;

            // Adjust the viewBox to match container's aspect ratio
            let adjustedWidth = contentWidth;
            let adjustedHeight = contentHeight;
            let adjustedX = minX;
            let adjustedY = minY;

            if (contentAspectRatio > containerAspectRatio) {
                // Content is wider than container
                adjustedHeight = contentWidth / containerAspectRatio;
                adjustedY = minY - (adjustedHeight - contentHeight) / 2;
            } else {
                // Content is taller than container
                adjustedWidth = contentHeight * containerAspectRatio;
                adjustedX = minX - (adjustedWidth - contentWidth) / 2;
            }

            // Create the SVG element with proper sizing
            const svg = document.createElementNS(svgNS, "svg");
            svg.style.width = "100%";
            svg.style.height = "100%";
            svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
            svg.setAttribute("viewBox", `${adjustedX} ${adjustedY} ${adjustedWidth} ${adjustedHeight}`);

            // For the background
            const fixedBg = document.createElementNS(svgNS, "rect");
            fixedBg.setAttribute("x", adjustedX);
            fixedBg.setAttribute("y", adjustedY);
            fixedBg.setAttribute("width", adjustedWidth);
            fixedBg.setAttribute("height", adjustedHeight);
            fixedBg.setAttribute("fill", "rgba(0,0,0,0)");
            fixedBg.addEventListener("mousedown", onCanvasMouseDown);
            svg.appendChild(fixedBg);

            // Create pan/zoom group for movable content only
            panZoomGroup = document.createElementNS(svgNS, "g");
            panZoomGroup.setAttribute("transform", `translate(${panOffset.tx}, ${panOffset.ty})`);
            svg.appendChild(panZoomGroup);

            svgElement = svg;
            zoomHandler = new SVGZoomHandler(svg);

            // Attach events to svg
            svgElement.addEventListener("mousemove", drag);
            svgElement.addEventListener("mouseup", endDrag);
            svgElement.addEventListener("mouseleave", endDrag);
            svgElement.addEventListener("wheel", (e) => zoomHandler.onWheel(e));
            svgElement.addEventListener("mousedown", (e) => {
                //if (e.button === 2) {
                //zoomHandler.onRightClickZoom(e);
                //}
            });
            svgElement.addEventListener("contextmenu", (e) => e.preventDefault());
            fixedBg.addEventListener("mousedown", onCanvasMouseDown);

            // Draw connections (wires)
            const connGroup = document.createElementNS(svgNS, "g");
            connGroup.setAttribute("stroke", "#555555");
            connGroup.setAttribute("fill", "none");
            connGroup.setAttribute("stroke-width", "1.5");
            connections.forEach((conn) => {
                let fromPos = null,
                    toPos = null;
                let isHiddenWire = false;

                // When finding positions for wires, also check for hidden wire status
                visibleComponents.forEach((comp) => {
                    comp.outputs.forEach((param) => {
                        if (param.instanceGuid === conn.fromOutputInstanceGuid) {
                            const pos = getParamPosition(param, "output");
                            fromPos = {
                                x: comp.bounds.x + comp.bounds.w,
                                y: pos.y
                            };
                        }
                    });
                    comp.inputs.forEach((param) => {
                        if (param.instanceGuid === conn.toInputInstanceGuid) {
                            const pos = getParamPosition(param, "input");
                            toPos = {
                                x: comp.bounds.x,
                                y: pos.y
                            };
                            // Check if this input has WireDisplay=2
                            if (param.wireDisplay === 2) {
                                isHiddenWire = true;
                            }
                        }
                    });
                });

                if (fromPos && toPos) {
                    const path = document.createElementNS(svgNS, "path");
                    const dx = toPos.x - fromPos.x;
                    const dy = toPos.y - fromPos.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const cp1x = fromPos.x + Math.min(distance * 0.4, 100);
                    const cp2x = toPos.x - Math.min(distance * 0.4, 100);
                    const d = `M ${fromPos.x} ${fromPos.y} C ${cp1x} ${fromPos.y}, ${cp2x} ${toPos.y}, ${toPos.x} ${toPos.y}`;

                    path.setAttribute('data-from', conn.fromOutputInstanceGuid);
                    path.setAttribute('data-to', conn.toInputInstanceGuid);
                    path.setAttribute("d", d);
                    path.setAttribute("stroke-opacity", "0.6");

                    // Apply dashed style for hidden wires
                    if (isHiddenWire) {
                        path.setAttribute("stroke-dasharray", "4,4");
                        path.setAttribute("stroke", "#888888"); // Lighter color for hidden wires
                    }

                    connGroup.appendChild(path);
                }
            });
            panZoomGroup.appendChild(connGroup);

            // Draw components
            // Inside the existing drawSVG function, modify the component drawing loop:
            visibleComponents.forEach((comp) => {
                const group = document.createElementNS(svgNS, "g");
                group.classList.add("draggable");
                group.setAttribute("data-guid", comp.instanceGuid);
                group.addEventListener("dblclick", (evt) => {
                    evt.stopPropagation();
                    handleComponentDoubleClick(comp);
                });
                group.addEventListener("mousedown", (evt) => startDrag(evt, comp));

                if (comp.name === "Sketch") {
                    renderSketch(comp.container, group);
                } else if (comp.name === "Scribble") {
                    renderScribble(comp, group);
                } else {
                    // Original component drawing code
                    // Create regular gradient definition
                    const gradient = document.createElementNS(svgNS, "linearGradient");
                    gradient.setAttribute("id", "rectGradient");
                    gradient.setAttribute("x1", "0%");
                    gradient.setAttribute("y1", "0%");
                    gradient.setAttribute("x2", "0%");
                    gradient.setAttribute("y2", "100%");

                    // Create gradient stops for normal components
                    const stop1 = document.createElementNS(svgNS, "stop");
                    stop1.setAttribute("offset", "0%");
                    stop1.setAttribute("style", "stop-color:#e5edf2;stop-opacity:0.75");

                    const stop2 = document.createElementNS(svgNS, "stop");
                    stop2.setAttribute("offset", "100%");
                    stop2.setAttribute("style", "stop-color:#c5d3db;stop-opacity:0.75");

                    gradient.appendChild(stop1);
                    gradient.appendChild(stop2);

                    // Create grey gradient definition for locked components
                    const greyGradient = document.createElementNS(svgNS, "linearGradient");
                    greyGradient.setAttribute("id", "greyGradient");
                    greyGradient.setAttribute("x1", "0%");
                    greyGradient.setAttribute("y1", "0%");
                    greyGradient.setAttribute("x2", "0%");
                    greyGradient.setAttribute("y2", "100%");

                    const greyStop1 = document.createElementNS(svgNS, "stop");
                    greyStop1.setAttribute("offset", "0%");
                    greyStop1.setAttribute("style", "stop-color:#999999;stop-opacity:0.65");

                    const greyStop2 = document.createElementNS(svgNS, "stop");
                    greyStop2.setAttribute("offset", "100%");
                    greyStop2.setAttribute("style", "stop-color:#777777;stop-opacity:0.65");

                    greyGradient.appendChild(greyStop1);
                    greyGradient.appendChild(greyStop2);

                    // Add both gradient definitions to a defs element
                    const defs = document.createElementNS(svgNS, "defs");
                    defs.appendChild(gradient);
                    defs.appendChild(greyGradient);
                    svg.appendChild(defs); // Append defs to your main SVG element

                    // Then modify your rectangle code
                    const rect = document.createElementNS(svgNS, "rect");
                    rect.setAttribute("x", comp.bounds.x);
                    rect.setAttribute("y", comp.bounds.y);
                    rect.setAttribute("width", comp.bounds.w);
                    rect.setAttribute("height", comp.bounds.h);
                    rect.setAttribute("stroke", "#1f1f1f");
                    rect.setAttribute("rx", "4");
                    rect.setAttribute("ry", "4");
                    rect.classList.add("draggable");

                    // Check if it's a placeholder using the stored GUIDs
                    const isPlaceholder = sectionGuids.placeHolders.has(comp.instanceGuid);

                    // Determine fill based on component type
                    if (isPlaceholder) {
                        rect.setAttribute("fill", "whitesmoke"); // Flat whitesmoke color
                        rect.setAttribute("fill-opacity", "0.95"); // Slightly transparent
                        rect.setAttribute("stroke", "#666666"); // Gray stroke for placeholders
                        rect.setAttribute("stroke-dasharray", "2,2"); // Add dashed border
                        rect.setAttribute("stroke-width", "0.75"); // Slightly thicker border
                    } else if (comp.locked && comp.locked.toLowerCase() === "true") {
                        rect.setAttribute("fill", comp.name === "Panel" ? "rgba(200, 200, 180, 0.9)" : "url(#greyGradient)");
                    } else {
                        rect.setAttribute("fill", comp.name === "Panel" ? "rgba(255, 250, 90, 0.75)" : "url(#rectGradient)");
                    }
                    group.appendChild(rect);

                    // Only add dashed rectangle for hidden components that are not placeholders
                    const isHidden = comp.hidden && comp.hidden.toLowerCase() === "true";
                    if (isHidden && !isPlaceholder) {
                        // Create inflated dashed boundary
                        const dashedBound = document.createElementNS(svgNS, "rect");
                        const inflation = 3;
                        dashedBound.setAttribute("x", comp.bounds.x - inflation);
                        dashedBound.setAttribute("y", comp.bounds.y - inflation);
                        dashedBound.setAttribute("width", comp.bounds.w + inflation * 2);
                        dashedBound.setAttribute("height", comp.bounds.h + inflation * 2);
                        dashedBound.setAttribute("stroke", "#555555");
                        dashedBound.setAttribute("stroke-width", "0.75");
                        dashedBound.setAttribute("stroke-dasharray", "2,2");
                        dashedBound.setAttribute("fill", "none");
                        dashedBound.setAttribute("rx", "5");
                        dashedBound.setAttribute("ry", "5");
                        group.appendChild(dashedBound);
                    }

                    // Create text element for name (positioned above component)
                    const text = document.createElementNS(svgNS, "text");
                    text.setAttribute("x", comp.bounds.x + comp.bounds.w / 2);
                    text.setAttribute("y", comp.bounds.y - 5); // Position above component
                    text.setAttribute("text-anchor", "middle");
                    text.setAttribute("dominant-baseline", "auto");
                    text.setAttribute("font-size", "12");
                    text.setAttribute("class", "component-name");
                    text.style.display = showComponentNames ? "block" : "none";
                    text.textContent = comp.nickname || comp.name;
                    text.classList.add("draggable");

                    // Set text color based on component type
                    if (isPlaceholder) {
                        text.setAttribute("fill", "#666666"); // Gray text for placeholders
                    } else {
                        text.setAttribute("fill", comp.locked ? "#000000" : "black");
                    }
                    group.appendChild(text);

                    // Try to load the icon first
                    const image = document.createElementNS(svgNS, "image");
                    const iconPath = getIconPath(comp.guid);

                    // Create a temporary Image object to check if the icon exists
                    const tempImg = new Image();
                    tempImg.onload = () => {
                        // Icon exists, use it and keep text above
                        image.setAttributeNS("http://www.w3.org/1999/xlink", "href", iconPath);
                        image.setAttribute("x", comp.bounds.x + (comp.bounds.w - ICON_SIZE) / 2);
                        image.setAttribute("y", comp.bounds.y + (comp.bounds.h - ICON_SIZE) / 2);
                        image.setAttribute("width", ICON_SIZE);
                        image.setAttribute("height", ICON_SIZE);
                        image.setAttribute("class", "component-icon");
                        group.appendChild(image);

                        // Keep text above component
                        text.setAttribute("y", comp.bounds.y - 5);
                    };
                    tempImg.onerror = () => {
                        // Icon doesn't exist, use text in center of component
                        text.setAttribute("y", comp.bounds.y + comp.bounds.h / 2);
                        text.style.display = "block"; // Always show text when no icon
                    };
                    tempImg.src = iconPath;

                    // Draw input/output ports
                    comp.inputs.forEach((param) => {
                        const pos = getParamPosition(param, "input");
                        const circle = document.createElementNS(svgNS, "circle");
                        circle.setAttribute("cx", comp.bounds.x);
                        circle.setAttribute("cy", pos.y);
                        circle.setAttribute("r", 3);
                        circle.setAttribute("fill", "#00ff00");
                        group.appendChild(circle);
                    });

                    comp.outputs.forEach((param) => {
                        const pos = getParamPosition(param, "output");
                        const circle = document.createElementNS(svgNS, "circle");
                        circle.setAttribute("cx", comp.bounds.x + comp.bounds.w);
                        circle.setAttribute("cy", pos.y);
                        circle.setAttribute("r", 3);
                        circle.setAttribute("fill", "#ff0000");
                        group.appendChild(circle);
                    });
                }

                panZoomGroup.appendChild(group);
            });

            // Replace existing SVG in the viewer
            svgViewer.innerHTML = "";
            svgViewer.appendChild(svg);
        }

        function isGroup(component) {
            // Check if it's a group component but not a group container
            if (component.guid === 'b0851fc0-ab55-47d8-bdda-cc6306a40176') {
                return false; // This is a group component, we want to show it
            }

            return (
                component.name === "GH_Group" ||
                (component.container?.querySelector('item[name="Name"]')?.textContent || "").includes("Group") &&
                component.container?.querySelector('item[name="Objects"]') !== null // Check if it's a group container
            );
        }

        svgViewer.addEventListener("contextmenu", function (e) {
            // If the user right-clicks directly on the container (and not on any SVG element inside),
            // prevent the context menu.
            if (e.target === svgViewer) {
                e.preventDefault();
            }
        });
        // Prevent default action for middle-click (button 1)
        svgViewer.addEventListener("mousedown", function (e) {
            if (e.button === 1) {
                e.preventDefault();
            }
        });

        svgViewer.addEventListener("auxclick", function (e) {
            if (e.button === 1) {
                e.preventDefault();
            }
        });
        // ----- DOUBLE-CLICK TO RESET VIEW -----
        svgViewer.addEventListener("dblclick", () => {
            const svg = document.querySelector("#svgViewer svg");
            if (svg) {
                zoomAll();
            }
        });

        function zoomAll() {
            const svg = document.querySelector("#svgViewer svg");
            if (!svg) return;
            // Reset any existing transform
            const panZoomGroup = svg.querySelector("g[transform]");
            if (panZoomGroup) {
                panZoomGroup.setAttribute("transform", "");
            }
            // Calculate the bounds of the SVG content
            const bounds = svg.getBBox();
            // Define a fixed margin
            const margin = 50;
            const inflated = {
                minX: bounds.x - margin,
                minY: bounds.y - margin,
                width: bounds.width + margin * 2,
                height: bounds.height + margin * 2
            };
            // Update the SVG viewBox
            svg.setAttribute("viewBox", `${inflated.minX} ${inflated.minY} ${inflated.width} ${inflated.height}`);
        }

        function attachLockedListeners() {
            // For each side-panel that has a locked checkbox:
            document.querySelectorAll(".componentPanel input.locked").forEach((lockedInput) => {
                lockedInput.addEventListener("change", function () {
                    const instanceGuid = this.closest(".componentPanel").dataset.guid;
                    // Determine if this component is a panel:
                    const isPanel = this.closest(".componentPanel")
                        .querySelector("h3")
                        .textContent.includes("Panel");
                    // Use the same locked/unlocked colors as above:
                    const newFill = this.checked
                        ? isPanel
                            ? "rgba(200, 200, 180, 0.9)"
                            : "url(#greyGradient)"
                        : isPanel
                            ? "rgba(255, 250, 90, 0.75)"
                            : "url(#rectGradient)";

                    // Find the SVG element (group) that corresponds to this component:
                    const svgGroup = svgElement.querySelector(`g[data-guid="${instanceGuid}"]`);
                    if (svgGroup) {
                        // Find the rectangle element inside this group (assuming it's the first rect):
                        const rect = svgGroup.querySelector("rect");
                        if (rect) {
                            rect.setAttribute("fill", newFill);
                        }
                    }
                });
            });
        }

        function attachHiddenListeners() {
            // For each side-panel that has a hidden checkbox:
            document.querySelectorAll(".componentPanel input.hidden").forEach((hiddenInput) => {
                hiddenInput.addEventListener("change", function () {
                    const instanceGuid = this.closest(".componentPanel").dataset.guid;
                    const svgGroup = svgElement.querySelector(`g[data-guid="${instanceGuid}"]`);

                    if (svgGroup) {
                        // Remove existing dashed boundary if it exists
                        const existingDashedBound = svgGroup.querySelector('rect[stroke-dasharray="2,2"]');
                        if (existingDashedBound) {
                            svgGroup.removeChild(existingDashedBound);
                        }

                        // If hidden is checked, create new dashed boundary
                        if (this.checked) {
                            const componentRect = svgGroup.querySelector("rect");
                            if (componentRect) {
                                const svgNS = "http://www.w3.org/2000/svg";
                                const dashedBound = document.createElementNS(svgNS, "rect");
                                const inflation = 3;

                                // Get component bounds from the existing rectangle
                                const x = parseFloat(componentRect.getAttribute("x"));
                                const y = parseFloat(componentRect.getAttribute("y"));
                                const width = parseFloat(componentRect.getAttribute("width"));
                                const height = parseFloat(componentRect.getAttribute("height"));

                                // Set attributes for dashed boundary
                                dashedBound.setAttribute("x", x - inflation);
                                dashedBound.setAttribute("y", y - inflation);
                                dashedBound.setAttribute("width", width + inflation * 2);
                                dashedBound.setAttribute("height", height + inflation * 2);
                                dashedBound.setAttribute("stroke", "#555555");
                                dashedBound.setAttribute("stroke-width", "0.75");
                                dashedBound.setAttribute("stroke-dasharray", "2,2");
                                dashedBound.setAttribute("fill", "none");
                                dashedBound.setAttribute("rx", "5");
                                dashedBound.setAttribute("ry", "5");

                                svgGroup.appendChild(dashedBound);
                            }
                        }
                    }
                });
            });
        }

        // Function to show popup message
        function showPopup(message, isError = false) {
            const popup = document.getElementById("popupMessage");
            popup.textContent = message;
            popup.classList.toggle("error", isError);
            popup.style.display = "block";
            requestAnimationFrame(() => {
                popup.classList.add("show");
                setTimeout(() => {
                    popup.classList.remove("show");
                    setTimeout(() => {
                        popup.style.display = "none";
                        popup.classList.remove("error");
                    }, 300);
                }, 2000);
            });
        }

        // Add click handler for section headers with highlight
        document.querySelectorAll(".sectionHeader").forEach((header) => {
            header.addEventListener("click", function () {
                // Remove selected class from all sections
                document.querySelectorAll(".sectionPanel").forEach((panel) => {
                    panel.classList.remove("selected");
                });

                // Add selected class to clicked section
                this.parentElement.classList.add("selected");

                // Toggle active state for pressed-in effect
                this.classList.toggle("active");
            });
        });

        // Restore double-click highlight for components
        function highlightComponent(component) {
            // Remove any existing highlights
            document.querySelectorAll(".highlight-orange").forEach((el) => {
                el.classList.remove("highlight-orange");
            });

            // Add orange highlight
            component.classList.add("highlight-orange");

            // Remove highlight after animation
            setTimeout(() => {
                component.classList.remove("highlight-orange");
            }, 1500);
        }

        // Remove the duplicate event listener and update the existing one
        svgViewer.addEventListener("dblclick", function (e) {
            const svgGroup = e.target.closest('.draggable');
            if (!svgGroup) return;

            e.stopPropagation();

            // Get the component's GUID
            const guid = svgGroup.getAttribute("data-guid");
            if (!guid) return;

            // Remove all existing highlights
            document.querySelectorAll(".sectionPanel.selected, .componentPanel.selected").forEach((el) => {
                el.classList.remove("selected");
            });

            // Find and highlight the corresponding componentPanel
            const componentPanel = document.querySelector(`.componentPanel[data-guid="${guid}"]`);
            if (componentPanel) {
                // Highlight the componentPanel
                componentPanel.classList.add("selected");

                // Highlight its parent section
                const sectionPanel = componentPanel.closest(".sectionPanel");
                if (sectionPanel) {
                    sectionPanel.classList.add("selected");

                    // Show the section content if it's hidden
                    const sectionContent = sectionPanel.querySelector(".sectionContent");
                    if (sectionContent) {
                        sectionContent.style.display = "block";
                    }
                }

                // Ensure the component panel is visible
                componentPanel.scrollIntoView({ behavior: "smooth", block: "nearest" });
            }

            // Add orange highlight animation
            svgGroup.classList.add("highlight-orange");
            setTimeout(() => {
                svgGroup.classList.remove("highlight-orange");
            }, 1500);
        });

        // Add click handler for component panels to highlight them
        document.addEventListener("click", function (e) {
            //zoomAll();
            // Find the closest componentPanel to the clicked element
            const componentPanel = e.target.closest(".componentPanel");
            if (componentPanel) {
                // Remove highlight from all panels and sections
                document.querySelectorAll(".componentPanel.selected, .sectionPanel.selected").forEach((p) => {
                    p.classList.remove("selected");
                });

                // Add highlight to clicked panel
                componentPanel.classList.add("selected");

                // Highlight parent section
                const sectionPanel = componentPanel.closest(".sectionPanel");
                if (sectionPanel) {
                    sectionPanel.classList.add("selected");

                    // Ensure section content is visible
                    const sectionContent = sectionPanel.querySelector(".sectionContent");
                    if (sectionContent) {
                        sectionContent.style.display = "block";
                    }
                }

                // Find and highlight corresponding SVG component
                const guid = componentPanel.dataset.guid;
                const svgComponent = document.querySelector(`g[data-guid="${guid}"] rect`);
                if (svgComponent) {
                    svgComponent.classList.add("highlight-orange");
                    setTimeout(() => {
                        svgComponent.classList.remove("highlight-orange");
                    }, 1500);
                }

                // Ensure the clicked panel is visible in the viewport
                componentPanel.scrollIntoView({ behavior: "smooth", block: "nearest" });

                // Get the component data from globalComponents
                const component = globalComponents.find(comp => comp.instanceGuid === guid);
                if (component) {
                    // Zoom to component after a short delay
                    setTimeout(() => {
                        zoomToComponent(component);
                    }, 100);
                }
            }
        });

        // Add this with the other DOM references
        const saveSvgBtn = document.getElementById("saveSvgBtn");

        // Replace the existing saveSvgBtn click handler with this:
        saveSvgBtn.addEventListener("click", () => {
            if (!svgElement) {
                showPopup("No SVG content to save!", true);
                return;
            }

            try {
                // Create a clone of the SVG for saving
                const svgClone = svgElement.cloneNode(true);

                // Find all component groups in the clone
                const groups = svgClone.querySelectorAll('g[data-guid]');

                groups.forEach(group => {
                    // Remove the icon
                    const icon = group.querySelector('.component-icon');
                    if (icon) {
                        icon.remove();
                    }

                    // Show and center the name
                    const text = group.querySelector('.component-name');
                    if (text) {
                        // Get the rect to position the text in the center
                        const rect = group.querySelector('rect');
                        if (rect) {
                            const x = parseFloat(rect.getAttribute('x'));
                            const y = parseFloat(rect.getAttribute('y'));
                            const height = parseFloat(rect.getAttribute('height'));

                            // Position text in center of component
                            text.setAttribute('y', y + height / 2);
                            text.setAttribute('dominant-baseline', 'middle');
                            text.style.display = 'block'; // Make sure text is visible
                        }
                    }
                });

                // Serialize SVG with proper namespaces and viewBox
                const serializer = new XMLSerializer();
                const svgString = serializer.serializeToString(svgClone);

                // Create proper SVG file header
                const fullSvg = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n${svgString}`;

                // Create download
                const blob = new Blob([fullSvg], { type: "image/svg+xml" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = fileName.replace(/\.[^/.]+$/, "") + ".svg";
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showPopup("SVG saved successfully!");
            } catch (error) {
                console.error("Error saving SVG:", error);
                showPopup("Error saving SVG!", true);
            }
        });

        // Add event listener for Alt+N toggle (add this near other event listeners)
        document.addEventListener("keydown", function (e) {
            if (e.altKey && (e.key === "n" || e.key === "N")) {
                showComponentNames = !showComponentNames;
                document.querySelectorAll(".component-name").forEach(text => {
                    text.style.display = showComponentNames ? "block" : "none";
                });
            }
        });

        // Add this function to handle missing icons gracefully
        function handleMissingIcon(image, comp) {
            image.addEventListener("error", function () {
                console.warn(`Icon not found for component with GUID: ${comp.instanceGuid}`);
                // Instead of removing the image, show the component name as fallback
                const text = this.parentNode.querySelector(".component-name");
                if (text) {
                    text.setAttribute("y", this.parentNode.querySelector("rect").getAttribute("y"));
                    text.style.display = "block"; // Always show name if icon is missing
                }
                this.remove();
            });
        }

        // Add this new function to handle component zooming
        function zoomToComponent(component, instant = false) {
            if (!component || !svgElement) return;

            const svgContainer = document.querySelector("#svgViewer");
            if (!svgContainer) return;

            // Reset transform first
            panZoomGroup.transform.baseVal.clear();
            const resetTransform = svgElement.createSVGTransform();
            panZoomGroup.transform.baseVal.appendItem(resetTransform);

            // Get the container's dimensions
            const containerRect = svgContainer.getBoundingClientRect();

            // Get the component's bounds with padding
            const padding = 30;
            const bounds = component.bounds;
            const targetWidth = bounds.w + padding * 2;
            const targetHeight = bounds.h + padding * 2;

            // Calculate the scale factor to fit the component in the container
            const scaleX = containerRect.width / targetWidth;
            const scaleY = containerRect.height / targetHeight;
            const scale = Math.min(scaleX, scaleY, 2); // Limit max zoom to 2x

            // Calculate the new viewBox dimensions
            const viewBoxWidth = containerRect.width / scale;
            const viewBoxHeight = containerRect.height / scale;

            // Center the component in the viewBox
            const centerX = bounds.x + bounds.w / 2;
            const centerY = bounds.y + bounds.h / 2;

            const viewBoxX = centerX - viewBoxWidth / 2;
            const viewBoxY = centerY - viewBoxHeight / 2;

            // Apply the new viewBox
            svgElement.setAttribute("viewBox", `${viewBoxX} ${viewBoxY} ${viewBoxWidth} ${viewBoxHeight}`);

            // Add overflow hidden to container if not already set
            svgContainer.style.overflow = "hidden";
        }

        // Add this function to convert image to base64
        function convertImageToBase64(imagePath) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    const dataURL = canvas.toDataURL('image/png');
                    resolve(dataURL);
                };
                img.onerror = () => reject(new Error('Failed to load image'));
                img.src = imagePath;
            });
        }

        // Modify the image creation in drawSVG function
        // Replace the existing image creation code with:
        const image = document.createElementNS(svgNS, "image");
        convertImageToBase64(getIconPath(comp.guid))
            .then(dataUrl => {
                image.setAttributeNS("http://www.w3.org/1999/xlink", "href", dataUrl);
            })
            .catch(error => {
                console.warn(`Failed to load icon for component: ${comp.guid}`, error);
            });
        image.setAttribute("x", comp.bounds.x + (comp.bounds.w - ICON_SIZE) / 2);
        image.setAttribute("y", comp.bounds.y + (comp.bounds.h - ICON_SIZE) / 2);
        image.setAttribute("width", ICON_SIZE);
        image.setAttribute("height", ICON_SIZE);
        image.setAttribute("class", "component-icon");
        group.appendChild(image);

        // Modify the saveSvgBtn click handler
        saveSvgBtn.addEventListener("click", async () => {
            if (!svgElement) {
                showPopup("No SVG content to save!", true);
                return;
            }

            try {
                // Wait for all images to be loaded and converted
                const images = Array.from(svgElement.querySelectorAll('image'));
                await Promise.all(images.map(async (img) => {
                    const href = img.getAttributeNS("http://www.w3.org/1999/xlink", "href");
                    if (href && href.startsWith('icons/')) {
                        try {
                            const dataUrl = await convertImageToBase64(href);
                            img.setAttributeNS("http://www.w3.org/1999/xlink", "href", dataUrl);
                        } catch (error) {
                            console.warn(`Failed to convert image: ${href}`, error);
                        }
                    }
                }));

                // Serialize SVG with proper namespaces and viewBox
                const serializer = new XMLSerializer();
                const svgString = serializer.serializeToString(svgElement);

                // Create proper SVG file header
                const fullSvg = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n${svgString}`;

                // Create download
                const blob = new Blob([fullSvg], { type: "image/svg+xml" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = fileName.replace(/\.[^/.]+$/, "") + ".svg";
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showPopup("SVG saved successfully!");
            } catch (error) {
                console.error("Error saving SVG:", error);
                showPopup("Error saving SVG!", true);
            }
        });

        // Update the save XML function:
        document.getElementById("saveXml").addEventListener("click", function () {
            try {
                const fileName = document.getElementById("fileName").value || "grasshopper";

                // Create a deep clone of the XML to avoid modifying the original
                const xmlClone = xmlDoc.cloneNode(true);

                // Clean up the XML before saving
                cleanupXML(xmlClone);

                // Format the XML with proper indentation
                const serializer = new XMLSerializer();
                let xmlString = serializer.serializeToString(xmlClone);
                xmlString = formatXMLString(xmlString);

                // Create proper XML file header
                const fullXml = `<?xml version="1.0" encoding="utf-8" standalone="yes"?>\n${xmlString}`;

                // Create and trigger download
                const blob = new Blob([fullXml], { type: "application/xml" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = fileName.replace(/\.[^/.]+$/, "") + ".ghx";
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showPopup("GHX saved successfully!");
            } catch (error) {
                console.error("Error saving GHX:", error);
                showPopup("Error saving GHX!", true);
            }
        });

        // Add these helper functions:
        function cleanupXML(node) {
            if (node.nodeType === Node.ELEMENT_NODE) {
                // Remove extra attributes
                if (node.hasAttribute("Locked")) {
                    node.removeAttribute("Locked");
                }

                // Format float values
                if (node.tagName === "X" || node.tagName === "Y" || node.tagName === "W" || node.tagName === "H") {
                    const value = parseFloat(node.textContent);
                    if (!isNaN(value)) {
                        node.textContent = value.toString();
                    }
                }

                // Recursively clean child nodes
                Array.from(node.children).forEach(child => cleanupXML(child));
            }
        }

        function formatXMLString(xmlString) {
            const INDENT = '  '; // Two spaces for indentation
            let formatted = '';
            let indent = '';

            // Split the string into lines and remove empty lines
            const lines = xmlString.trim().split('\n');

            lines.forEach(line => {
                // Decrease indent for closing tags
                if (line.match(/^<\//)) {
                    indent = indent.slice(2);
                }

                // Add line with proper indentation
                formatted += indent + line.trim() + '\n';

                // Increase indent for opening tags (if not self-closing)
                if (line.match(/^<[^/]/) && !line.match(/[^?]\/>/)) {
                    indent += INDENT;
                }
            });

            return formatted;
        }

        // When updating wire display:
        function updateWireDisplayInXML(componentId, wireDisplay) {
            const componentNode = findComponentNodeById(componentId);
            if (componentNode) {
                const wireDisplayNode = componentNode.querySelector('item[name="WireDisplay"]');
                if (wireDisplayNode) {
                    wireDisplayNode.textContent = wireDisplay;
                } else {
                    // Create new WireDisplay node if it doesn't exist
                    const newNode = xmlDoc.createElement('item');
                    newNode.setAttribute('name', 'WireDisplay');
                    newNode.setAttribute('type_name', 'gh_int32');
                    newNode.setAttribute('type_code', '3');
                    newNode.textContent = wireDisplay;
                    componentNode.appendChild(newNode);
                }
            }
        }

        // Helper function to find component node in XML
        function findComponentNodeById(id) {
            return xmlDoc.querySelector(`chunk[name="Container"] > items > item[name="InstanceGuid"][type_name="gh_guid"]:contains("${id}")`);
        }

    </script>
</body>

</html>